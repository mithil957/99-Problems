{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>References</p> <ul> <li>Prolog 99 Problems</li> <li>Ocaml 99 Problems</li> <li>Python 99 Problems</li> <li>Lisp 99 Problems</li> <li>Joy</li> </ul> <p>This project is a collection of programming problems largely inspired by the orignal 99 Prolog problems. Each problem has a description, test cases, and sometimes multiple different ways to solve the problem.  The aim is to learn by understanding different ways to approach a problem. </p> <p>This collection includes both the classic problems and new problems. Each implemented using modern Python (3.13). </p> <p>Most of the problems are self contained, so you can start anywhere and they are tagged with a difficulty level (Beginner, Intermediate, Advanced) which is searchable. You can also search for general tags like (List, Tree, Arithmetic, Logic, Graph, Pattern) if you would like to focus on a certain type of problem.</p> <p>*Sorry for the misleading title, it is 65 questions currently. Eventually, it will be 99 problems.</p> <p>Source Code</p>"},{"location":"problems/p01_tail_of_list/","title":"Tail of a List","text":"<p>Write a function that returns the last element of a list.</p> TestPattern MatchingRecursiveDirect <pre><code>def test_tail_of_list(solution):\n    assert solution([]) is None\n    assert solution([1]) == 1\n    assert solution([1, 2, 3]) == 3\n    assert solution(['a', 'b', 'c']) == 'c'\n</code></pre> <pre><code>def tail_of_list_v1[T](lst: list[T]) -&gt; T | None:\n    match lst:\n        case []: return None\n        case [a]: return a\n        case [*front, last]: return last\n</code></pre> <pre><code>def tail_of_list_v2[T](lst: list[T]) -&gt; T | None:\n    match lst:\n        case []: return None\n        case [a]: return a\n        case [head, *tail]: return tail_of_list_v2(tail)\n</code></pre> <pre><code>def tail_of_list_v3[T](lst: list[T]) -&gt; T | None:\n    return lst[-1] if len(lst) &gt; 0 else None\n</code></pre>","tags":["List","Beginner"]},{"location":"problems/p02_last_two_elements_of_a_list/","title":"Last Two Elements of a List","text":"<p>Find the last two elements of a list.</p> TestPattern MatchingRecursiveDirect <pre><code>def test_last_two_elements_of_a_list(solution):\n    assert solution([]) is None\n    assert solution([1]) is None\n    assert solution([1, 2, 3]) == (2, 3)\n    assert solution(['a', 'b', 'c', 'd']) == ('c', 'd')\n</code></pre> <pre><code>def last_two_elements_of_a_list_v1[T](lst: list[T]) -&gt; tuple[T, T] | None:\n    match lst:\n        case [] | [_]: return None\n        case [a, b]: return (a, b)\n        case [*front, penultimate, last]: return (penultimate, last)\n</code></pre> <pre><code>def last_two_elements_of_a_list_v2[T](lst: list[T]) -&gt; tuple[T, T] | None:\n    match lst:\n        case [] | [_]: return None\n        case [a, b]: return (a, b)\n        case _: return last_two_elements_of_a_list_v2(lst[1:])\n</code></pre> <pre><code>def last_two_elements_of_a_list_v3[T](lst: list[T]) -&gt; tuple[T, T] | None:\n    return (lst[-2], lst[-1]) if len(lst) &gt;= 2 else None\n</code></pre>","tags":["List","Beginner"]},{"location":"problems/p03_nth_element_of_list/","title":"Nth Element of a List","text":"<p>Find the Nth element of a list.</p> TestRecursiveDirect <pre><code>def test_nth_element_of_list(solution):\n    assert solution([], 5) is None\n    assert solution([1], 5) is None\n    assert solution([1], 0) is 1\n    assert solution([1, 2, 3], 2) == 3\n    assert solution(['a', 'b', 'c', 'd'], 2) == 'c'\n    assert solution(['a', 'b', 'c', 'd'], 89) is None\n</code></pre> <pre><code>def nth_element_of_list_v1[T](lst: list[T], n: int) -&gt; T | None:\n    match (lst, n):\n        case ([], _): return None\n        case ([a, *tail], 0): return a\n        case _: return nth_element_of_list_v1(lst[1:], n - 1)\n</code></pre> <pre><code>def nth_element_of_list_v2[T](lst: list[T], n: int) -&gt; T | None:\n    match 0 &lt;= n &lt; len(lst):\n        case True: return lst[n]\n        case False: return None\n</code></pre>","tags":["List","Beginner"]},{"location":"problems/p04_length_of_list/","title":"Length of a List","text":"<p>Find the number of elements in a list.</p> TestDirectRecursiveTail Recursive <pre><code>def test_length_of_list(solution):\n    assert solution([]) == 0\n    assert solution([1]) == 1\n    assert solution([1, 2, 3]) == 3\n    assert solution(['a', 'b', 'c', 'd']) == 4\n</code></pre> <pre><code>def number_of_elements_in_list_v1[T](lst: list[T]) -&gt; int:\n    return len(lst)\n</code></pre> <pre><code>def number_of_elements_in_list_v2[T](lst: list[T]) -&gt; int:\n    match lst:\n        case []: return 0\n        case [a]: return 1\n        case [a, *tail]: return 1 + number_of_elements_in_list_v2(tail)\n</code></pre> <pre><code>def number_of_elements_in_list_v3[T](lst: list[T]) -&gt; int:\n    def aux(current_lst: list[T], accumulated: int) -&gt; int:\n        match current_lst:\n            case []: return accumulated\n            case [a]: return 1 + accumulated\n            case [a, *tail]: return aux(tail, accumulated + 1)\n\n    return aux(lst, 0)\n</code></pre>","tags":["List","Beginner"]},{"location":"problems/p05_reverse_a_list/","title":"Reverse a List","text":"<p>Reverse a list.</p> TestDirectRecursiveTail Recursive <pre><code>def test_reverse_a_list(solution):\n    assert solution([]) == []\n    assert solution([1]) == [1]\n    assert solution([1, 2, 3]) == [3, 2, 1]\n    assert solution(['a', 'b', 'c', 'd']) == ['d', 'c', 'b', 'a']\n</code></pre> <pre><code>def reverse_list_v1[T](lst: list[T]) -&gt; list[T]:\n    return lst[::-1]\n</code></pre> <pre><code>def reverse_list_v2[T](lst: list[T]) -&gt; list[T]:\n    match lst:\n        case []: return []\n        case [a]: return [a]\n        case [head, *tail]: return reverse_list_v2(tail) + [head]\n</code></pre> <pre><code>def reverse_list_v3[T](lst: list[T]) -&gt; list[T]:\n    def aux(current_lst: list[T], accumlated: list[T]) -&gt; list[T]:\n        match current_lst:\n            case []: return accumlated\n            case [a]: return accumlated + [a]\n            case [head, *tail]: return aux(tail, accumlated + [head])\n\n    return aux(lst, [])\n</code></pre>","tags":["List","Beginner"]},{"location":"problems/p06_palindrome/","title":"Palindrome","text":"<p>Find out whether a list is a palindrome. A palindrome is its own reverse.</p> TestDirectRecursiveTail Recursive <pre><code>    def test_palindrome(solution):\n        assert solution([]) == True\n        assert solution([1]) == True\n        assert solution([1, 1]) == True\n        assert solution([1, 2]) == False\n        assert solution([1, 2, 3]) == False\n        assert solution(['a', 'b', 'b', 'a']) == True\n        assert solution(['a', 'b', 'c', 'b', 'a']) == True\n        assert solution(['r', 'a', 'c', 'e', 'c', 'a', 'r']) == True\n</code></pre> <pre><code>def check_palindrome_v1[T](lst: list[T]) -&gt; bool:\n    return lst == lst[::-1]\n</code></pre> <pre><code>def check_palindrome_v2[T](lst: list[T]) -&gt; bool:\n    match lst:\n        case []: return True\n        case [a]: return True\n        case [first, *body, last]: \n            return (first == last) and check_palindrome_v2(body)\n</code></pre> <pre><code>def check_palindrome_v3[T](lst: list[T]) -&gt; bool:\n    def aux(current_lst: list[T], same_so_far: bool) -&gt; bool:\n        if not same_so_far: return False\n\n        match current_lst:\n            case []: return True\n            case [a]: return True\n            case [first, *body, last]: \n                return aux(body, first == last)\n\n    return aux(lst, True)\n</code></pre>","tags":["List","Beginner"]},{"location":"problems/p07_flatten_a_list/","title":"Flatten a List","text":"<p>Flatten a nested list structure. The list is allowed to be arbitrarily deep.</p> TestRecursiveIterative <pre><code>def test_flatten_a_list(solution):\n    assert solution([]) == []\n    assert solution([1]) == [1]\n\n    assert solution([1, 2, 3]) == [1, 2, 3]\n    assert solution(['a', 'b', 'b', 'a']) == ['a', 'b', 'b', 'a']\n\n    assert solution(['a', ['b'], 'b', ['a']]) == ['a', 'b', 'b', 'a']\n    assert solution([[1, 2], 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n    assert solution([[1, 2], \n                    [[3, 4], 5], \n                    [[[]]], \n                    [6, 7]]) == [1, 2, 3, 4, 5, 6, 7]\n\n    assert solution([[[[[[[[1]]]]]]]]) == [1]\n</code></pre> <pre><code>def flatten_list_v1[T](lst: list[T]) -&gt; list[T]:\n    def aux(accumulated: list[T], working_lst: list[T]) -&gt; list[T]:\n        match working_lst:\n            case []: \n                return accumulated\n\n            case [nested_list, *tail] if type(nested_list) is list:\n                flatten_nested_list = aux([], nested_list)\n                return aux(accumulated + flatten_nested_list, tail)\n\n            case [single_element, *tail]: \n                return aux(accumulated + [single_element], tail)\n\n    return aux([], lst)\n</code></pre> <pre><code>from copy import deepcopy\n\ndef flatten_list_v2[T](lst: list[T]) -&gt; list[T]:\n    accumulated = []\n    stack = [deepcopy(lst)]\n\n    while stack:\n        match stack[-1]:\n            case []:\n                stack.pop()\n\n            case nested_list if type(nested_list) is list:\n                stack.append(nested_list.pop(0))\n\n            case single_element:\n                stack.pop() \n                accumulated.append(single_element)\n\n    return accumulated\n</code></pre>","tags":["List","Intermediate"]},{"location":"problems/p08_eliminate_duplicates/","title":"Eliminate Duplicates","text":"<p>Eliminate consecutive duplicates of list elements.</p> TestRecursiveIterativeDirect <pre><code>def test_eliminate_duplicates(solution):\n    assert solution([]) == []\n    assert solution([1]) == [1]\n\n    assert solution([1, 2, 3]) == [1, 2, 3]\n    assert solution([1, 1, 2]) == [1, 2]\n    assert solution([1, 2, 2]) == [1, 2]\n\n    assert solution(['a', 'b', 'b', 'c', 'c', 'd', 'a', 'd']) == ['a', 'b', 'c', 'd', 'a', 'd']\n</code></pre> <pre><code>def eliminate_consecutive_duplicates_v1[T](lst: list[T]) -&gt; list[T]:\n    match lst:\n        case []: return []\n        case [a]: return [a]\n        case [a, b, *tail]:\n            if a != b: \n                return [a] + eliminate_consecutive_duplicates_v1(lst[1:])\n            else: \n                return eliminate_consecutive_duplicates_v1(lst[1:])\n</code></pre> <pre><code>from copy import deepcopy\n\ndef eliminate_consecutive_duplicates_v2[T](lst: list[T]) -&gt; list[T]:\n    accumulated: list[T] = []\n    working_list: list[T] = deepcopy(lst)\n\n    while working_list:\n        match working_list:\n            case []: \n                return accumulated\n\n            case [a]: \n                return accumulated + [a]\n\n            case [first, second, *body] if first == second: \n                working_list.pop(0)\n\n            case [first, second, *body]:\n                accumulated.append(first)\n                working_list.pop(0)\n\n    return accumulated\n</code></pre> <pre><code>from itertools import groupby\n\ndef eliminate_consecutive_duplicates_v3[T](lst: list[T]) -&gt; list[T]:\n    return [key for key, group in groupby(lst)]\n</code></pre>","tags":["List","Intermediate"]},{"location":"problems/p09_run_length_encoding/","title":"Run-Length Encoding","text":"<p>Run-length encoding (RLE) is encoding a list by mapping a sequence of the same element into the length of the sequence and the element.</p> <pre><code>[(elem1, # of consecutive terms), (elem2, # of consecutive terms), ...]\n</code></pre> TestRecursiveReduce/FoldDirect <pre><code>def test_run_length_encoding(solution):\n    assert solution([]) == []\n    assert solution([1]) == [(1, 1)]\n\n    assert solution([1, 2, 3]) == [(1, 1), (2, 1), (3, 1)]\n    assert solution([1, 1, 2]) == [(1, 2), (2, 1)]\n    assert solution([1, 2, 2]) == [(1, 1), (2, 2)]\n\n    assert solution(['a', 'b', 'b', 'c', 'c', 'd', 'a', 'd']) == \\\n        [('a', 1), ('b', 2), ('c', 2), ('d', 1), ('a', 1), ('d', 1)]\n</code></pre> <pre><code>from collections import namedtuple\n\nRleTerm = namedtuple(\"RleTerm\", [\"elem\", \"count\"])\n\ndef rle_encode_v1[T](lst: list[T]) -&gt; list[RleTerm]:\n    def aux(working_list: list[T], encoding: list[RleTerm]) -&gt; list[RleTerm]:\n        match working_list:\n            case []: \n                return encoding\n\n            case [head, *tail] if (last_term := encoding[-1]).elem == head:\n                updated_term = RleTerm(last_term.elem, last_term.count + 1)\n                encoding[-1] = updated_term\n                return aux(tail, encoding)\n\n            case [head, *tail]:\n                encoding.append(RleTerm(head, 1))\n                return aux(tail, encoding)\n\n    if len(lst) == 0: return []\n    return aux(lst[1:], [RleTerm(lst[0], 1)])\n</code></pre> <pre><code>from functools import reduce\nfrom collections import namedtuple\n\nRleTerm = namedtuple(\"RleTerm\", [\"elem\", \"count\"])\n\ndef rle_encode_v2[T](lst: list[T]) -&gt; list[RleTerm]:\n    def helper(left: list[RleTerm], right: T) -&gt; list[RleTerm]:\n        match left[-1]:\n            case RleTerm(item, count) if item == right:\n                left[-1] = RleTerm(item, count + 1)\n\n            case _:\n                left.append(RleTerm(right, 1))\n\n        return left\n\n    if len(lst) == 0: return []\n    return reduce(helper, lst[1:], [RleTerm(lst[0], 1)])\n</code></pre> <pre><code>from itertools import groupby\nfrom collections import namedtuple\n\nRleTerm = namedtuple(\"RleTerm\", [\"elem\", \"count\"])\n\ndef rle_encode_v3[T](lst: list[T]) -&gt; list[RleTerm]:\n    return [RleTerm(key, len(list(group))) \n            for key, group in groupby(lst)]\n</code></pre>","tags":["List","Beginner"]},{"location":"problems/p10_modified_run_length_encoding/","title":"Modified Run-Length Encoding","text":"<p>RLE but for elements with 1 count just append the element only. </p> Test4fun/DSLDirect <pre><code>def test_modifed_run_length_encoding(solution):\n    assert solution([]) == []\n    assert solution([1]) == [1]\n\n    assert solution([1, 2, 3]) == [1, 2, 3]\n    assert solution([1, 1, 2]) == [(1, 2), 2]\n    assert solution([1, 2, 2]) == [1, (2, 2)]\n\n    assert solution(['a', 'b', 'b', 'c', 'c', 'd', 'a', 'd']) == \\\n        ['a', ('b', 2), ('c', 2), 'd', 'a', 'd']\n</code></pre> <pre><code>from __future__ import annotations\nfrom functools import reduce\n\ntype RleTerm[T] = tuple[T, int] | T\n\nclass RleList:\n    working_list: list[RleTerm]\n\n    def __init__(self, init_element: RleTerm):\n        self.working_list = [init_element]\n\n    def __or__[T](self, value: T) -&gt; RleList:\n        match self.working_list[-1]:\n            case (elem, count) if elem == value:\n                self.working_list[-1] = (elem, count + 1)\n            case (elem, count):\n                self.working_list.append(value)\n\n            case elem if elem == value:\n                self.working_list[-1] = (elem, 2)\n            case elem:\n                self.working_list.append(value)\n\n        return self\n\ndef modded_rle_encode_v1[T](lst: list[T]) -&gt; list[RleTerm]:\n    if len(lst) == 0: return []\n    return reduce(lambda l, r: l | r, \n                  lst[1:], \n                  RleList(lst[0])).working_list\n</code></pre> <pre><code>from itertools import groupby\n\ntype RleTerm[T] = tuple[T, int] | T\n\ndef modded_rle_encode_v2[T](lst: list[T]) -&gt; list[RleTerm]:\n    def aux(key, group):\n        if len(group) == 1: return key\n        else: return (key, len(group))\n\n    return [aux(key, list(group)) for key, group in groupby(lst)]\n</code></pre>","tags":["List","Beginner"]},{"location":"problems/p11_decode_run_length_encoding/","title":"Decode a Run-Length Encoded List","text":"<p>Given a run-length encoded list, construct its uncompressed version.</p> TestRecursiveGenerator <pre><code>def test_decode_rle_list(solution):\n    assert solution([]) == []\n    assert solution([1]) == [1]\n\n    assert solution([1, 2, 3]) == [1, 2, 3]\n    assert solution([(1, 2), 2]) == [1, 1, 2]\n    assert solution([1, (2, 2)]) == [1, 2, 2]\n\n    assert solution(['a', ('b', 2), ('c', 2), 'd', 'a', 'd']) == \\\n        ['a', 'b', 'b', 'c', 'c', 'd', 'a', 'd']\n</code></pre> <pre><code>type RleTerm[T] = tuple[T, int] | T \n\ndef decode_rle_list_v1[T](rle_lst: list[RleTerm]) -&gt; list[T]:\n    match rle_lst:\n        case []: \n            return []\n        case [(element, count), *tail]:\n            return [element] * count + decode_rle_list_v1(rle_lst[1:])\n        case [element, *tail]:\n            return [element] + decode_rle_list_v1(rle_lst[1:])\n</code></pre> <pre><code>from typing import Generator\n\ntype RleTerm[T] = tuple[T, int] | T \n\ndef decode_rle_list_v2[T](rle_lst: list[RleTerm]) -&gt; list[T]:\n    def aux() -&gt; Generator[T]:\n        for term in rle_lst:\n            match term:\n                case (element, count): yield from (element for _ in range(count))\n                case element: yield element\n\n    return list(aux())\n</code></pre>","tags":["List","Intermediate"]},{"location":"problems/p12_duplicate_the_elements_of_a_list/","title":"Duplicate the Elements of a List","text":"<p>Duplicate the elements of a list.</p> TestRecursiveMap/SumZipReduceComprehension <pre><code>def test_duplicate_elements(solution):\n    assert solution([]) == []\n    assert solution([1]) == [1, 1]\n\n    assert solution([1, 2, 3]) == [1, 1, 2, 2, 3, 3]\n    assert solution([1, 2, 2]) == [1, 1, 2, 2, 2, 2]\n\n    assert solution(['a', 'b', 'b', 'c', 'c', 'd', 'a', 'd']) == \\\n        ['a', 'a', \n         'b', 'b', 'b', 'b', \n         'c', 'c', 'c', 'c', \n         'd', 'd',\n         'a', 'a',\n         'd', 'd']\n</code></pre> <pre><code>def duplicate_elements_v1[T](lst: list[T]) -&gt; list[T]:\n    match lst:\n        case []: return []\n        case [head, *tail]: return [head, head] + duplicate_elements_v1(lst[1:])\n</code></pre> <pre><code>def duplicate_elements_v2[T](lst: list[T]) -&gt; list[T]:\n    return sum(map(lambda x: [x, x], lst), [])\n</code></pre> <pre><code>from itertools import chain\n\ndef duplicate_elements_v3[T](lst: list[T]) -&gt; list[T]:\n    return list(chain(*zip(lst, lst)))\n</code></pre> <pre><code>from functools import reduce\n\ndef duplicate_elements_v4[T](lst: list[T]) -&gt; list[T]:\n    return reduce(lambda l, r: l + [r, r], lst, [])\n</code></pre> <pre><code>def duplicate_elements_v5[T](lst: list[T]) -&gt; list[T]:\n    return [elem for elem in lst \n                 for _ in range(2)]\n</code></pre>","tags":["List","Beginner"]},{"location":"problems/p13_replicate_elements_n_times/","title":"Replicate the Elements of a List a Given Number of Times","text":"<p>Replicate the elements of a list a given number of times.</p> TestRecursiveMatrix LikeChain/RepeatReduceComprehension <pre><code>def test_replicate_elements(solution):\n    assert solution([], 0) == []\n    assert solution([], 5) == []\n\n    assert solution([1], 0) == []\n    assert solution([1], 1) == [1]\n    assert solution([1], 3) == [1, 1, 1]\n\n    assert solution([1, 2, 3], 0) == []\n    assert solution([1, 2, 2], 1) == [1, 2, 2]\n    assert solution([1, 2, 2], 3) == [1, 1, 1, 2, 2, 2, 2, 2, 2]\n\n    assert solution(['a', 'b', 'b', 'c', 'c', 'd', 'a', 'd'], 4) == \\\n        ['a', 'a', 'a', 'a',\n        'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b',\n        'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c',\n        'd', 'd', 'd', 'd',\n        'a', 'a', 'a', 'a',\n        'd', 'd', 'd', 'd']\n</code></pre> <pre><code>def replicate_elements_v1[T](lst: list[T], times: int) -&gt; list[T]:\n    match (lst, times):\n        case ([], _) | (_, 0): \n            return []\n        case (_, 1): \n            return lst\n        case ([head, *tail], times): \n            return ([head] * times) + replicate_elements_v1(tail, times)\n</code></pre> <pre><code>from itertools import chain, repeat\n\ndef replicate_elements_v2[T](lst: list[T], times: int) -&gt; list[T]:\n    return list(chain(*zip(*repeat(lst, times))))\n</code></pre> <pre><code>from itertools import chain\n\ndef replicate_elements_v3[T](lst: list[T], times: int) -&gt; list[T]:\n    return list(chain(*(repeat(elem, times) for elem in lst)))\n</code></pre> <pre><code>from functools import reduce\n\ndef replicate_elements_v4[T](lst: list[T], times: int) -&gt; list[T]:\n    return reduce(lambda l, r: l + [r] * times, lst, [])\n</code></pre> <pre><code>def replicate_elements_v5[T](lst: list[T], times: int) -&gt; list[T]:\n    return [elem for elem in lst \n                 for _ in range(times)]\n</code></pre>","tags":["List","Intermediate"]},{"location":"problems/p14_drop_every_nth_element/","title":"Drop Every Nth Element From a List","text":"<p>Drop every Nth element from a list. If N is 2, then every second element should be dropped.</p> TestRecursiveGenerator/ComprehensionChainMask <pre><code>def test_drop_every_nth_element(solution):\n    assert solution([], 0) == []\n    assert solution([], 5) == []\n\n    assert solution([1], 0) == [1]\n    assert solution([1], 1) == []\n    assert solution([1], 3) == [1]\n\n    assert solution([1, 2, 3], 0) == [1, 2, 3]\n    assert solution([1, 2, 2], 1) == []\n    assert solution([1, 2, 2], 3) == [1, 2]\n\n    assert solution(['a', 'b', 'b', 'c', 'c', 'd', 'a', 'd'], 4) == \\\n        ['a', 'b', 'b', 'c', 'd', 'a']\n</code></pre> <pre><code>def drop_every_nth_element_v1[T](lst: list[T], n: int) -&gt; list[T]:\n    if n == 0: \n        return lst\n\n    def aux(left: tuple[list[T], int], right: T) -&gt; tuple[list[T], int]:\n        acummulated, index_tracker = left\n        if index_tracker % n != 0: \n            acummulated.append(right)\n        return (acummulated, index_tracker + 1)\n\n    acummulated, _ = reduce(aux, lst, ([], 1))\n    return acummulated\n</code></pre> <pre><code>def drop_every_nth_element_v2[T](lst: list[T], n: int) -&gt; list[T]:\n    if n == 0: \n        return lst\n\n    generator_exp = (value \n                     for idx, value in enumerate(lst, 1)\n                     if idx % n != 0)\n\n    return list(generator_exp)\n</code></pre> <pre><code>from itertools import chain\n\ndef drop_every_nth_element_v3[T](lst: list[T], n: int) -&gt; list[T]:\n    if n == 0:\n        return lst\n\n    step = n\n    return list(chain.from_iterable(\n        lst[idx: idx + step - 1] \n        for idx in range(0, len(lst), step)\n    ))\n</code></pre> <pre><code>from itertools import compress, cycle\n\ndef drop_every_nth_element_v4[T](lst: list[T], n: int) -&gt; list[T]:\n    if n == 0:\n        return lst\n\n    mask = [True] * (n - 1) + [False]\n    repeated_mask = cycle(mask)\n    return list(compress(lst, repeated_mask))\n</code></pre>","tags":["List","Intermediate"]},{"location":"problems/p15_split_list_into_two_parts/","title":"Split a List Into Two Parts","text":"<p>Split a list into two parts. The lenght of the first part is given. If the length of the first part is longer than the entire list, then the first part is the list and the second list is empty.</p> TestRecursiveSliceIterativeisliceDeque <pre><code>def test_split_list(solution):\n    assert solution([], 0) == ([], [])\n    assert solution([], 5) == ([], [])\n\n    assert solution([1], 0) == ([], [1])\n    assert solution([1], 1) == ([1], [])\n    assert solution([1], 3) == ([1], [])\n\n    assert solution([1, 2, 3], 0) == ([], [1, 2, 3])\n    assert solution([1, 2, 2], 1) == ([1], [2, 2])\n    assert solution([1, 2, 2], 3) == ([1, 2, 2], [])\n\n    assert solution(['a', 'b', 'b', 'c', 'c', 'd', 'a', 'd'], 4) == \\\n        (['a', 'b', 'b', 'c'], ['c', 'd', 'a', 'd'])\n</code></pre> <pre><code>def split_list_v1[T](lst: list[T], split_point: int) -&gt; tuple[list[T], list[T]]:\n    def aux[T](p1: list[T], p2:list[T], idx: int) -&gt; tuple[list[T], list[T]]:\n        match (idx &lt; split_point, idx &gt;= len(lst)):\n            case (_, True): \n                return p1, p2\n            case (True, _): \n                return aux(p1 + [lst[idx]], p2, idx + 1)\n            case (False, _): \n                return aux(p1, p2 + [lst[idx]], idx + 1)\n\n    return aux([], [], 0)\n</code></pre> <pre><code>def split_list_v2[T](lst: list[T], split_point: int) -&gt; tuple[list[T], list[T]]:\n    return lst[:split_point], lst[split_point:]\n</code></pre> <pre><code>def split_list_v3[T](lst: list[T], split_point: int) -&gt; tuple[list[T], list[T]]:\n    p1, p2 = [], []\n    for idx, value in enumerate(lst, 1):\n        if idx &lt;= split_point: p1.append(value)\n        else: p2.append(value)\n\n    return p1, p2\n</code></pre> <pre><code>def split_list_v4[T](lst: list[T], split_point: int) -&gt; tuple[list[T], list[T]]:\n    p1 = islice(lst, split_point)\n    p2 = islice(lst, split_point, None)\n    return list(p1), list(p2)\n</code></pre> <pre><code>def split_list_v5[T](lst: list[T], split_point: int) -&gt; tuple[list[T], list[T]]:\n    split_point = min(split_point, len(lst))\n    queue = deque(lst)\n\n    p1 = [queue.popleft() for _ in range(split_point)]\n    p2 = list(queue)\n    return p1, p2\n</code></pre>","tags":["List","Beginner"]},{"location":"problems/p16_extract_slice/","title":"Extract a Slice From a List","text":"<p>Given two indices, i and k, the slice is the list containing the elements between the ith and kth element of the original list (inclusive). No negative slices.</p> TestRecursiveSliceComprehensionMask <pre><code>def test_extract_slice(solution):\n    assert solution([], 0, 0) == []\n    assert solution([], 0, 1) == []\n    assert solution([], 0, 5) == []\n    assert solution([], 3, 5) == []\n\n    assert solution([1], 0, 0) == [1]\n    assert solution([1], 0, 1) == [1]\n    assert solution([1], 1, 1) == []\n    assert solution([1], 0, 5) == [1]\n    assert solution([1], 3, 5) == []\n\n    assert solution([1, 2, 3], 0, 0) == [1]\n    assert solution([1, 2, 3], 0, 1) == [1, 2]\n    assert solution([1, 2, 3], 0, 2) == [1, 2, 3]\n    assert solution([1, 2, 3], 1, 2) == [2, 3]\n    assert solution([1, 2, 3], 2, 3) == [3]\n    assert solution([1, 2, 3], 4, 7) == []\n\n    assert solution(['a', 'b', 'b', 'c', 'c', 'd', 'a', 'd'], 4, 6) == \\\n        ['c', 'd', 'a']\n</code></pre> <pre><code>def extract_slice_v1[T](lst: list[T], start: int, stop: int) -&gt; list[T]:\n    terminal_point = min(stop + 1, len(lst))\n\n    def aux(accumlated: list[T], idx: int) -&gt; list[T]:\n        match (start &lt;= idx &lt;= stop, idx &gt;= terminal_point):\n            case (_, True): return accumlated\n            case (False, _): return aux(accumlated, idx + 1)\n            case (True, _): return aux(accumlated + [lst[idx]], idx + 1)\n\n    return aux([], 0)\n</code></pre> <pre><code>def extract_slice_v2[T](lst: list[T], start: int, stop: int) -&gt; list[T]:\n    return lst[start:stop+1]\n</code></pre> <pre><code>def extract_slice_v3[T](lst: list[T], start: int, stop: int) -&gt; list[T]:\n    return list(elem \n                for idx, elem in enumerate(lst) \n                if start &lt;= idx &lt;= stop)\n</code></pre> <pre><code>from itertools import repeat, compress, chain\n\ndef extract_slice_v4[T](lst: list[T], start: int, stop: int) -&gt; list[T]:\n    falses_at_start = repeat(False, start)\n    trues_for_slice = repeat(True, stop - start + 1)\n    mask = chain(falses_at_start, trues_for_slice)\n    return list(compress(lst, mask))\n</code></pre>","tags":["List","Intermediate"]},{"location":"problems/p17_rotate_list_n_places_to_left/","title":"Rotate a List N Places to the Left","text":"<p>Rotate a list N places to the left. </p> TestRecursiveSliceChainDeque <pre><code>def test_rotate_left(solution):\n    assert solution([], 0) == []\n    assert solution([], 1) == []\n    assert solution([], 5) == []\n\n    assert solution([1], 0) == [1]\n    assert solution([1], 1) == [1]\n    assert solution([1], 100) == [1]\n\n    assert solution([1, 2, 3], 0) == [1, 2, 3]\n    assert solution([1, 2, 3], 1) == [2, 3, 1]\n    assert solution([1, 2, 3], 2) == [3, 1, 2]\n    assert solution([1, 2, 3], 3) == [1, 2, 3]\n    assert solution([1, 2, 3], 4) == [2, 3, 1]\n    assert solution([1, 2, 3], 100) == [2, 3, 1]\n\n    assert solution(['a', 'b', 'b', 'c', 'c', 'd', 'a', 'd'], 4) == \\\n        ['c', 'd', 'a', 'd', 'a', 'b', 'b', 'c']\n</code></pre> <pre><code>def rotate_left_v1[T](lst: list[T], times: int) -&gt; list[T]:\n    if len(lst) &lt;= 1: return lst\n\n    match times % len(lst):\n        case 0: return lst\n        case _: return rotate_left_v1(lst[1:] + lst[:1], times - 1)\n</code></pre> <pre><code>def rotate_left_v2[T](lst: list[T], times: int) -&gt; list[T]:\n    if len(lst) &lt;= 1: return lst\n    times = times % len(lst)\n    return lst[times:] + lst[:times]\n</code></pre> <pre><code>from itertools import chain\n\ndef rotate_left_v3[T](lst: list[T], times: int) -&gt; list[T]:\n    if len(lst) &lt;= 1: return lst\n    times = times % len(lst)\n    path = chain(range(times, len(lst)), \n                 range(0, times))\n    return [lst[idx] for idx in path]\n</code></pre> <pre><code>from collections import deque\n\ndef rotate_left_v4[T](lst: list[T], times: int) -&gt; list[T]:\n    d = deque(lst)\n    d.rotate(-times)\n    return list(d)\n</code></pre>","tags":["List","Intermediate"]},{"location":"problems/p18_remove_kth_element/","title":"Remove the Kth Element From a List","text":"<p>Remove the kth element from a list and return the list. Out of bounds index returns the list with no changes.</p> TestRecursiveDirectComprehensionSlice <pre><code>def test_remove_kth_element(solution):\n    assert solution([], 0) == []\n    assert solution([], 1) == []\n    assert solution([], 5) == []\n\n    assert solution([1], 0) == []\n    assert solution([1], 1) == [1]\n    assert solution([1], 100) == [1]\n\n    assert solution([1, 2, 3], 0) == [2, 3]\n    assert solution([1, 2, 3], 1) == [1, 3]\n    assert solution([1, 2, 3], 2) == [1, 2]\n    assert solution([1, 2, 3], 3) == [1, 2, 3]\n    assert solution([1, 2, 3], 4) == [1, 2, 3]\n\n    assert solution(['a', 'b', 'b', 'c', 'c', 'd', 'a', 'd'], 4) == \\\n        ['a', 'b', 'b', 'c', 'd', 'a', 'd']\n</code></pre> <pre><code>def remove_kth_element_v1[T](lst: list[T], remove_at: int) -&gt; list[T]:\n    def aux(working_lst: list[T], current_idx: int) -&gt; list[T]:\n        match (current_idx == remove_at, current_idx &gt;= len(lst)):\n            case (_, True): \n                return working_lst\n            case (True, _): \n                return aux(working_lst, current_idx + 1)\n            case (False, _): \n                return aux(working_lst + [lst[current_idx]], current_idx + 1)\n\n    return aux([], 0) if 0 &lt;= remove_at &lt; len(lst) else lst\n</code></pre> <pre><code>def remove_kth_element_v2[T](lst: list[T], remove_at: int) -&gt; list[T]:\n    if 0 &lt;= remove_at &lt; len(lst): \n        lst.pop(remove_at)\n    return lst\n</code></pre> <pre><code>def remove_kth_element_v3[T](lst: list[T], remove_at: int) -&gt; list[T]:\n    return [elem for idx, elem in enumerate(lst) if idx != remove_at]\n</code></pre> <pre><code>def remove_kth_element_v4[T](lst: list[T], remove_at: int) -&gt; list[T]:\n    if 0 &lt;= remove_at &lt; len(lst): \n        return lst[:remove_at] + lst[remove_at+1:]\n    return lst\n</code></pre>","tags":["List","Beginner"]},{"location":"problems/p19_insert_element_at_idx/","title":"Insert an Element at a Given Position Into a List","text":"<p>Start counting list elements with 0. Insert the element at the index.</p> <p>If index &gt;= length of the list, add to the end. Otherwise, return the list unchanged. </p> TestRecursiveDirectSlice <pre><code>def test_insert_element(solution):\n    elem = 42\n\n    assert solution([], elem, 0) == [elem]\n    assert solution([], elem, 1) == [elem]\n    assert solution([], elem, 5) == [elem]\n\n    assert solution([1], elem, 0) == [elem, 1]\n    assert solution([1], elem, 1) == [1, elem]\n    assert solution([1], elem, 100) == [1, elem]\n    assert solution([1], elem, -37) == [1]\n\n    assert solution([1, 2, 3], elem, 0) == [elem, 1, 2, 3]\n    assert solution([1, 2, 3], elem, 1) == [1, elem, 2, 3]\n    assert solution([1, 2, 3], elem, 2) == [1, 2, elem, 3]\n    assert solution([1, 2, 3], elem, 3) == [1, 2, 3, elem]\n    assert solution([1, 2, 3], elem, 4) == [1, 2, 3, elem]\n    assert solution([1, 2, 3], elem, -44) == [1, 2, 3]\n\n    elem = '42'\n\n    assert solution(['a', 'b', 'b', 'c', 'c', 'd', 'a', 'd'], elem, 4) == \\\n        ['a', 'b', 'b', 'c', elem, 'c', 'd', 'a', 'd']\n</code></pre> <pre><code>def insert_element_v1[T](lst: list[T], value: T, insert_at: int) -&gt; list[T]:\n    def aux(accumulated: list[T], current_index: int) -&gt; list[T]:\n        at_insert_indx = current_index == insert_at\n        reached_end = current_index &gt;= len(lst)\n\n        match (at_insert_indx, reached_end):\n            case (_, True): \n                return accumulated\n\n            case (True, _): \n                return aux(accumulated + [value, lst[current_index]],\n                           current_index + 1)\n\n            case (False, _):\n                return aux(accumulated + [lst[current_index]], \n                           current_index + 1)\n\n    if insert_at &gt;= len(lst) or lst == []: return lst + [value]\n    elif insert_at &lt; 0: return lst\n    else: return aux([], 0)\n</code></pre> <pre><code>def insert_element_v2[T](lst: list[T], value: T, insert_at: int) -&gt; list[T]:\n    if insert_at &gt; len(lst): \n        return lst + [value]\n    elif insert_at &lt; 0: \n        return lst\n    else:\n        lst.insert(insert_at, value)\n        return lst\n</code></pre> <pre><code>def insert_element_v3[T](lst: list[T], value: T, insert_at: int) -&gt; list[T]:\n    if insert_at &lt; 0: return lst\n    else: return lst[:insert_at] + [value] + lst[insert_at:]\n</code></pre>","tags":["List","Beginner"]},{"location":"problems/p20_create_list_given_range/","title":"Create a List Containing All Integers Within a Given Range","text":"<p>Create a list containing all integers within a given range. If first argument is greater than second, produce a list in decreasing order. </p> TestRecursiveDirectItertools <pre><code>def test_create_range(solution):\n    assert solution(0, 0) == [0]\n    assert solution(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    assert solution(5, 3) == [5, 4, 3]\n    assert solution(-2, 2) == [-2, -1, 0, 1, 2]\n</code></pre> <pre><code>def create_range_v1(start: int, end: int) -&gt; list[int]:\n    def aux(accumulated: list[int], direction: int, remaining: int) -&gt; list[int]:\n        if remaining == 0: \n            return accumulated\n        else: \n            return aux(accumulated + [accumulated[-1] + direction], direction, remaining - 1)\n\n    direction = 1 if end &gt;= start else -1\n    return aux([start], direction, abs(start - end))\n</code></pre> <pre><code>def create_range_v2(start: int, end: int) -&gt; list[int]:\n    direction = 1 if end &gt;= start else -1\n    return list(range(start, end + direction, direction))\n</code></pre> <pre><code>from itertools import count, takewhile\n\ndef create_range_v3(start: int, end: int) -&gt; list[int]:\n    if start &lt;= end:\n        direction = 1\n        stop_condition = lambda x: x &lt;= end\n    else:\n        direction = -1\n        stop_condition = lambda x: x &gt;= end\n\n    counter = count(start, direction)\n    bounded_counter = takewhile(stop_condition, counter)\n    return list(bounded_counter)\n</code></pre>","tags":["List","Beginner"]},{"location":"problems/p21_extract_K_elements_randomly/","title":"Extract a Given Number of Randomly Selected Elements From a List","text":"<p>Select K items from a list and return them. If K is bigger than length of list, return None. The items should be unique, not allowed to select the same index twice.</p> <p> TestSampleShuffle <pre><code>def test_extract_elements(solution):\n    assert solution([1, 2, 3], 0) == []\n    assert solution([1, 2, 3], 4) is None\n    assert solution([1, 2, 3], 10) is None\n    assert len(solution([1, 2, 3], 3)) == 3\n    assert len(solution([1, 2, 3], 2)) == 2\n</code></pre> <pre><code>from random import sample\n\ndef extract_elements_v1[T](lst: list[T], k: int) -&gt; list[T] | None:\n    if k &gt; len(lst): return None\n    return sample(lst, k)\n</code></pre> <pre><code>from random import shuffle\n\ndef extract_elements_v2[T](lst: list[T], k: int) -&gt; list[T] | None:\n    if k &gt; len(lst): return None\n    copy_lst = lst[:]\n    shuffle(copy_lst)\n    return copy_lst[:k]\n</code></pre>","tags":["List","Intermediate"]},{"location":"problems/p22_generate_combinations_from_list/","title":"Generate Combinations","text":"<p>Generate the combinations of K objects from the N elements of a list. We will pick K times without repeating any previous objects. This is known as combination without replacement. </p> TestRecursiveBFSGenerator/RecursiveDirect <pre><code>def test_generate_combinations(solution):\n    assert set(solution([1, 2, 3, 4], 1)) == set(combinations([1, 2, 3, 4], 1))\n    assert set(solution([1, 2, 3, 4], 2)) == set(combinations([1, 2, 3, 4], 2))\n    assert set(solution([1, 2, 3, 4, 5], 3)) == set(combinations([1, 2, 3, 4, 5], 3))\n    assert set(solution(['a', 'b', 'c', 'd'], 3)) == set(combinations(['a', 'b', 'c', 'd'], 3))\n    assert set(solution(['a', 'b', 'c', 'd'], 10)) == set(combinations(['a', 'b', 'c', 'd'], 10))\n    assert set(solution(list(range(20)), 10)) == set(combinations(list(range(20)), 10))\n</code></pre> <pre><code>def generate_combinations_v1[T](lst: list[T], num_of_items: int) -&gt; list[tuple[T]]:\n    valid_selections = []\n\n    def aux(selected: tuple[T], remaining_choices: list[T]):\n        if len(selected) + len(remaining_choices) &lt; num_of_items:\n            return\n\n        if len(selected) == num_of_items:\n            valid_selections.append(selected)\n            return\n\n        for idx, choice in enumerate(remaining_choices):\n            aux(selected + (choice,), remaining_choices[idx + 1:])\n\n    aux((), lst)\n    return valid_selections\n</code></pre> <pre><code>from collections import deque\n\ndef generate_combinations_v2[T](lst: list[T], num_of_items: int) -&gt; list[tuple[T]]:\n    valid_selections = []\n    nodes = deque([((), lst)])\n\n    while nodes:\n        selected, remaining_choices = nodes.popleft()\n\n        for idx, choice in enumerate(remaining_choices):\n            new_selection = selected + (choice,)\n            new_remaining_choices = remaining_choices[idx+1:]\n\n            if len(new_selection) == num_of_items:\n                valid_selections.append(new_selection)\n\n            elif len(selected) + len(remaining_choices) &gt;= num_of_items:\n                nodes.append((new_selection, new_remaining_choices))\n\n    return valid_selections\n</code></pre> <pre><code>from typing import Generator\n\ndef generate_combinations_v3[T](lst: list[T], num_of_items: int) -&gt; list[tuple[T]]:\n    def combinations_iter(lst: list[T], num_of_items: int) -&gt; Generator[tuple[T]]:\n        if len(lst) == 0 or num_of_items &gt; len(lst):\n            return\n\n        if num_of_items == 0:\n            yield ()\n            return\n\n        if len(lst) == num_of_items:\n            yield tuple(lst)\n            return\n\n        head, *tail = lst\n\n        yield from ((head,) + selection for selection in combinations_iter(tail, num_of_items - 1))\n        yield from combinations_iter(tail, num_of_items)\n\n    return list(combinations_iter(lst, num_of_items))\n</code></pre> <pre><code>from itertools import combinations\n\ndef generate_combinations_v4[T](lst: list[T], num_of_items: int) -&gt; list[tuple[T]]:\n    return list(combinations(lst, num_of_items))\n</code></pre>","tags":["List","Intermediate"]},{"location":"problems/p23_generate_permutations_from_list/","title":"Generate Permutations","text":"<p>Generate the permutations of K objects from the N elements of a list. We will pick K times without repeating any previous objects. This is known as permutation without replacement. </p> <p> TestRecursiveBFSGenerator/RecursiveDirect <pre><code>def test_generate_permutations(solution):\n    assert set(solution([1, 2, 3, 4], 1)) == set(permutations([1, 2, 3, 4], 1))\n    assert set(solution([1, 2, 3, 4], 2)) == set(permutations([1, 2, 3, 4], 2))\n    assert set(solution([1, 2, 3, 4, 5], 3)) == set(permutations([1, 2, 3, 4, 5], 3))\n    assert set(solution([1, 2, 3, 4, 5, 6], 4)) == set(permutations([1, 2, 3, 4, 5, 6], 4))\n    assert set(solution(['a', 'b', 'c', 'd'], 3)) == set(permutations(['a', 'b', 'c', 'd'], 3))\n    assert set(solution(['a', 'b', 'c', 'd'], 10)) == set(permutations(['a', 'b', 'c', 'd'], 10))\n    assert set(solution(list(range(10)), 7)) == set(permutations(list(range(10)), 7))\n</code></pre> <pre><code>def generate_permutations_v1[T](lst: list[T], num_of_items: int) -&gt; list[tuple[T]]:\n    accumulated = []\n\n    def aux(selected: tuple[T], remaining_choices: list[T]):\n        if len(selected) + len(remaining_choices) &lt; num_of_items:\n            return\n\n        if len(selected) == num_of_items:\n            accumulated.append(selected)\n            return\n\n        for idx, choice in enumerate(remaining_choices):\n            aux(selected + (choice,), remaining_choices[:idx] + remaining_choices[idx + 1:])\n\n    aux((), lst)\n    return accumulated\n</code></pre> <pre><code>from collections import deque\n\ndef generate_permutations_v2[T](lst: list[T], num_of_items: int) -&gt; list[tuple[T]]:\n    accumulated = []\n    nodes = deque([((), lst)])\n\n    while nodes:\n        selected, remaining_choices = nodes.popleft()\n\n        for idx, choice in enumerate(remaining_choices):\n            new_selected = selected + (choice,)\n            new_remaining_choices = remaining_choices[:idx] + remaining_choices[idx + 1:]\n\n            if len(new_selected) == num_of_items:\n                accumulated.append(new_selected)\n            elif len(new_selected) + len(new_remaining_choices) &gt;= num_of_items:\n                nodes.append((new_selected, new_remaining_choices))\n\n    return accumulated\n</code></pre> <pre><code>from typing import Generator\n\ndef generate_permutations_v3[T](lst: list[T], num_of_items: int) -&gt; list[tuple[T]]:\n    def permutations_iter(lst: list[T], num_of_items: int) -&gt; Generator[tuple[T]]:\n        if len(lst) == 0 or num_of_items &gt; len(lst):\n            return\n\n        if num_of_items == 0:\n            yield ()\n            return\n\n        yield from ((val,) + perm\n                    for idx, val in enumerate(lst)\n                    for perm in permutations_iter(lst[:idx] + lst[idx + 1:], num_of_items - 1))\n\n    return list(permutations_iter(lst, num_of_items))\n</code></pre> <pre><code>from itertools import permutations\n\ndef generate_permutations_v4[T](lst: list[T], num_of_items: int) -&gt; list[tuple[T]]:\n    return list(permutations(lst, num_of_items))\n</code></pre>","tags":["List","Intermediate"]},{"location":"problems/p24_generate_combinations_with_replacement/","title":"Generate Combinations with Replacement","text":"<p>Generate the combinations of K objects from the N elements of a list. We will pick K times but we are allowed to pick the same element more than once. This is known as combination with replacement. </p> TestRecursiveBFSGenerator/RecursiveDirect <pre><code>def test_combinations_with_replacement(solution):\n    assert set(solution([1, 2, 3, 4], 0)) == set(combinations_with_replacement([1, 2, 3, 4], 0))\n    assert set(solution([1, 2, 3, 4], 1)) == set(combinations_with_replacement([1, 2, 3, 4], 1))\n    assert set(solution([1, 2, 3, 4], 2)) == set(combinations_with_replacement([1, 2, 3, 4], 2))\n    assert set(solution([1, 2, 3, 4, 5], 3)) == set(combinations_with_replacement([1, 2, 3, 4, 5], 3))\n    assert set(solution([1, 2, 3, 4, 5, 6], 4)) == set(combinations_with_replacement([1, 2, 3, 4, 5, 6], 4))\n    assert set(solution([1, 2, 3, 4, 5], 6)) == set(combinations_with_replacement([1, 2, 3, 4, 5], 6))\n    assert set(solution(['a', 'b', 'c', 'd'], 3)) == set(combinations_with_replacement(['a', 'b', 'c', 'd'], 3))\n    assert set(solution(['a', 'b', 'c', 'd'], 10)) == set(combinations_with_replacement(['a', 'b', 'c', 'd'], 10))\n    assert set(solution(list(range(10)), 10)) == set(combinations_with_replacement(list(range(10)), 10))\n</code></pre> <pre><code>def combinations_with_replacement_v1[T](lst: list[T], num_of_items: int) -&gt; list[tuple[T]]:\n    if num_of_items == 0: return [()]\n    valid_selections = []\n\n    def aux(selected: tuple[T], remaining_choices: list[T]):\n        if len(selected) == num_of_items:\n            valid_selections.append(selected)\n            return\n\n        for idx, choice in enumerate(remaining_choices):\n            aux(selected + (choice,), remaining_choices[idx:])\n\n    aux((), lst)\n    return valid_selections\n</code></pre> <pre><code>from collections import deque\n\ndef combinations_with_replacement_v2[T](lst: list[T], num_of_items: int) -&gt; list[tuple[T]]:\n    if num_of_items == 0: return [()]\n    valid_selections = []\n    nodes = deque([((), lst)])\n\n    while nodes:\n        selected, remaining_choices = nodes.popleft()\n\n        for idx, val in enumerate(remaining_choices):\n            new_selected = selected + (val,)\n            new_remaining_choices = remaining_choices[idx:]\n\n            if len(new_selected) == num_of_items:\n                valid_selections.append(new_selected)\n            else:\n                nodes.append((new_selected, new_remaining_choices))\n\n    return valid_selections\n</code></pre> <pre><code>from typing import Generator\n\ndef combinations_with_replacement_v3[T](lst: list[T], num_of_items: int) -&gt; list[tuple[T]]:\n    def combinations_iter(lst: list[T], num_of_items: int) -&gt; Generator[tuple[T]]:\n        if len(lst) == 0:\n            return\n\n        if num_of_items == 0:\n            yield ()\n            return\n\n        head, *tail = lst\n        yield from ((head,) + combo for combo in combinations_iter(lst, num_of_items - 1))\n        yield from combinations_iter(tail, num_of_items)\n\n    return list(combinations_iter(lst, num_of_items))\n</code></pre> <pre><code>from itertools import combinations_with_replacement\n\ndef combinations_with_replacement_v4[T](lst: list[T], num_of_items: int) -&gt; list[tuple[T]]:\n    return list(combinations_with_replacement(lst, num_of_items))\n</code></pre>","tags":["List","Intermediate"]},{"location":"problems/p25_generate_permutations_with_replacement/","title":"Permutations with replacement","text":"<p>Generate the permutations of K objects from the N elements of a list. Repeats are allowed. </p> TestRecursiveBFSGenerator/RecursiveDirect <pre><code>def test_permutations_with_replacement(solution):\n    assert set(solution([1], 2)) == set(product([1], repeat=2))\n    assert set(solution([1, 2], 2)) == set(product([1, 2], repeat=2))\n    assert set(solution([1, 2, 3, 4], 0)) == set(product([1, 2, 3, 4], repeat=0))\n    assert set(solution([1, 2, 3, 4], 1)) == set(product([1, 2, 3, 4], repeat=1))\n    assert set(solution([1, 2, 3, 4], 2)) == set(product([1, 2, 3, 4], repeat=2))\n    assert set(solution([1, 2, 3, 4, 5], 3)) == set(product([1, 2, 3, 4, 5], repeat=3))\n    assert set(solution([1, 2, 3, 4, 5, 6], 4)) == set(product([1, 2, 3, 4, 5, 6], repeat=4))\n    assert set(solution([1, 2, 3, 4, 5], 6)) == set(product([1, 2, 3, 4, 5], repeat=6))\n    assert set(solution(['a', 'b', 'c', 'd'], 3)) == set(product(['a', 'b', 'c', 'd'], repeat=3))\n    assert set(solution(['a', 'b', 'c', 'd'], 10)) == set(product(['a', 'b', 'c', 'd'], repeat=10))\n</code></pre> <pre><code>def permutations_with_replacement_v1[T](lst: list[T], num_of_items: int) -&gt; list[tuple[T]]:\n    if len(lst) == 0: return []\n    if num_of_items == 0: return [()]\n\n    valid_selections = []\n\n    def aux(selection: tuple[T]):\n        if len(selection) == num_of_items:\n            valid_selections.append(selection)\n            return\n\n        for val in lst:\n            aux(selection + (val,))\n\n    aux(())\n    return valid_selections\n</code></pre> <pre><code>from collections import deque\n\ndef permutations_with_replacements_v2[T](lst: list[T], num_of_items: int) -&gt; list[tuple[T]]:\n    if len(lst) == 0: return []\n    if num_of_items == 0: return [()]\n\n    valid_selections = []\n    nodes = deque([()])\n\n    while nodes:\n        selected = nodes.popleft()\n\n        for val in lst:\n            new_selected = selected + (val,)\n\n            if len(new_selected) == num_of_items:\n                valid_selections.append(new_selected)\n            else:\n                nodes.append(new_selected)\n\n    return valid_selections\n</code></pre> <pre><code>from typing import Generator\n\ndef permutations_with_replacements_v3[T](lst: list[T], num_of_items: int) -&gt; list[tuple[T]]:\n    def permutations_iter(lst: list[T], num_of_items: int) -&gt; Generator[tuple[T]]:\n        if len(lst) == 0:\n            return\n\n        if num_of_items == 0:\n            yield ()\n            return\n\n        yield from ((val,) + perm\n                    for val in lst\n                    for perm in permutations_iter(lst, num_of_items - 1))\n\n    return list(permutations_iter(lst, num_of_items))\n</code></pre> <pre><code>from itertools import product\n\ndef permutations_with_replacements_v4[T](lst: list[T], num_of_items: int) -&gt; list[tuple[T]]:\n    return list(product(lst, repeat=num_of_items))\n</code></pre>","tags":["List","Intermediate"]},{"location":"problems/p26_group_set_into_disjoint_subsets/","title":"Ordered Partitions","text":"<p>Group the elements of a set into disjoint subsets. Given elements and the group sizes, generate all possible groups.</p> TestGenerator/RecursiveBFS <pre><code>def test_disjoint_subsets(solution):\n    assert len(solution(['a','b', 'c', 'd'], [2, 1])) == len([\n        [(\"a\", \"b\"), (\"c\")], [(\"a\", \"c\"),(\"b\")], [(\"b\", \"c\"), (\"a\")],\n        [(\"a\", \"b\"), (\"d\")], [(\"a\", \"c\"),(\"d\")], [(\"b\", \"c\"), (\"d\")],\n        [(\"a\", \"d\"), (\"b\")], [(\"b\", \"d\"),(\"a\")], [(\"a\", \"d\"), (\"c\")],\n        [(\"b\", \"d\"), (\"c\")], [(\"c\", \"d\"),(\"a\")], [(\"c\", \"d\"), (\"b\")]\n    ])\n\n    assert len(solution(['a','b', 'b'], [2, 1])) == len([\n        [(\"a\", \"b\"), (\"b\")], [(\"a\", \"b\"),(\"b\")], [(\"b\", \"b\"), (\"a\")],\n    ])\n\n    assert len(solution([1, 2, 3, 4, 5], [1, 3, 1])) == len([\n        [(1), (2, 3, 4), (5)], [(1), (2, 3, 5), (4)], [(1), (2, 4, 5), (3)], [(1), (3, 4, 5), (2)],\n        [(2), (1, 3, 4), (5)], [(2), (1, 3, 5), (4)], [(2), (1, 4, 5), (3)], [(2), (3, 4, 5), (1)],\n        [(3), (1, 2, 4), (5)], [(3), (1, 2, 5), (4)], [(3), (1, 4, 5), (2)], [(3), (2, 4, 5), (1)],\n        [(4), (1, 2, 3), (5)], [(4), (1, 2, 5), (3)], [(4), (1, 3, 5), (2)], [(4), (2, 3, 5), (1)],\n        [(5), (1, 2, 3), (4)], [(5), (1, 2, 4), (3)], [(5), (1, 3, 4), (2)], [(5), (2, 3, 4), (1)]\n    ])\n\n    assert len(solution(['a', 'b', 'c', 'd'], [2, 2])) == len([\n        [('a', 'b'), ('c', 'd')],\n        [('a', 'c'), ('b', 'd')],\n        [('a', 'd'), ('b', 'c')],\n        [('b', 'c'), ('a', 'd')],\n        [('b', 'd'), ('a', 'c')],\n        [('c', 'd'), ('a', 'b')]\n    ])\n</code></pre> <pre><code>from itertools import combinations\nfrom typing import Generator\n\ntype Partition[T] = list[tuple[T]] # Ex. [1,2,3,4] -&gt; [(1,2), (3), (4)]\n\ndef generate_ordered_partitions_v1[T](lst: list[T], group_sizes: list[int]) -&gt; list[Partition]:\n    def disjoint_subsets_iter(remaining_idxs: list[int], group_sizes: list[int]) -&gt; Generator[Partition]:\n        if len(group_sizes) == 0:\n            yield [] \n            return\n\n        if group_sizes[0] &gt; len(lst):\n            return\n\n        yield from ([tuple(lst[selected] for selected in combo_idxs)] + partition\n                    for combo_idxs in combinations(remaining_idxs, group_sizes[0])\n                    for partition in disjoint_subsets_iter(remaining_idxs - set(combo_idxs), group_sizes[1:]))\n\n    idxs = set(range(len(lst)))\n    return list(disjoint_subsets_iter(idxs, group_sizes))\n</code></pre> <pre><code>from itertools import combinations\nfrom collections import deque\n\ntype Partition[T] = list[tuple[T]] # Ex. [1,2,3,4] -&gt; [(1,2), (3), (4)]\n\ndef generate_ordered_partitions_v2[T](lst: list[T], group_sizes: list[int]) -&gt; list[Partition]:\n    valid_partitions = []\n    idxs = set(range(len(lst)))\n    nodes = deque([(idxs, 0, [])])\n\n    while nodes:\n        remaining_idxs, group_size_idx, partition = nodes.popleft()\n\n        for combo_idxs in combinations(remaining_idxs, group_sizes[group_size_idx]):\n            new_remaining_idxs = remaining_idxs - set(combo_idxs)\n            next_group_size_idx = group_size_idx + 1\n            updated_partition = partition + [tuple(lst[selected] for selected in combo_idxs)]\n\n            if next_group_size_idx &gt;= len(group_sizes):\n                valid_partitions.append(updated_partition)\n\n            elif len(new_remaining_idxs) &gt;= group_sizes[next_group_size_idx]:\n                nodes.append((new_remaining_idxs, next_group_size_idx, updated_partition))\n\n    return valid_partitions\n</code></pre>","tags":["List","Intermediate"]},{"location":"problems/p27_sort_lists_based_on_length/","title":"Sort Lists based on Length","text":"<p>Sort a list of lists according to the length of sublists.</p> TestMerge SortDirect <pre><code>def test_sort_sublists_by_length(solution):\n    assert [len(t) for t in solution([\n        [\"a\", \"b\", \"c\"], [\"d\", \"e\"], [\"f\", \"g\", \"h\"], [\"d\", \"e\"],\n        [\"i\", \"j\", \"k\", \"l\"], [\"m\", \"n\"], [\"o\"]])] ==\\\n            [len(t) for t in [[\"o\"], [\"d\", \"e\"], [\"d\", \"e\"], [\"m\", \"n\"], \n            [\"a\", \"b\", \"c\"], [\"f\", \"g\", \"h\"], [\"i\", \"j\", \"k\", \"l\"]]]\n</code></pre> <pre><code>from typing import Callable\n\ntype Comparison[T] = Callable[[T, T], bool]\n\ndef merge_sort[T](lst: list[T], less_than: Comparison) -&gt; list[T]:\n    def merge_sorted_lists(left_list: list[T], right_list: list[T]) -&gt; list[T]:\n        match (left_list, right_list):\n            case ([], _) | (_, []):\n                return left_list + right_list\n\n            case ([left_head, *left_tail], [right_head, *right_tail]):\n                if less_than(left_head, right_head):\n                    return [left_head] + merge_sorted_lists(left_tail, right_list)\n                else:\n                    return [right_head] + merge_sorted_lists(left_list, right_tail)\n\n    match lst:\n        case [] | [_]: \n            return lst\n        case _: \n            mid_point = len(lst) // 2\n            left, right = lst[:mid_point], lst[mid_point:]\n            sorted_left, sorted_right = merge_sort(left, less_than), merge_sort(right, less_than) \n            return merge_sorted_lists(sorted_left, sorted_right)\n\n\ndef sort_sublists_by_length_v1[T](lst: list[list[T]]) -&gt; list[list[T]]:\n    return merge_sort(lst, lambda l, r: len(l) &lt; len(r))\n</code></pre> <pre><code>def sort_sublists_by_length_v2[T](lst: list[list[T]]) -&gt; list[list[T]]:\n    return sorted(lst, key=lambda l: len(l))\n</code></pre>","tags":["List","Intermediate"]},{"location":"problems/p28_sort_lists_based_on_frequency_of_length/","title":"Sort Lists based on Frequency","text":"<p>Sort a list of lists based on their length frequency. Lists with rare lengths are placed first. Lists with more frequent lengths come later.</p> TestDirect <pre><code>def test_sort_by_frequency_of_length(solution):\n    assert [len(t) for t in solution([\n            [\"a\", \"b\", \"c\"], [\"d\", \"e\"], [\"f\", \"g\", \"h\"], [\"d\", \"e\"],\n            [\"i\", \"j\", \"k\", \"l\"], [\"m\", \"n\"], [\"o\"]])\n        ] ==\\\n            [len(t) for t in [\n                [\"i\", \"j\", \"k\", \"l\"], [\"o\"], [\"a\", \"b\", \"c\"], [\"f\", \"g\", \"h\"], [\"d\", \"e\"], [\"d\", \"e\"], [\"m\", \"n\"]]\n            ]\n</code></pre> <pre><code>from collections import Counter\n\ndef sort_by_frequency_of_length_v1[T](lst: list[list[T]]) -&gt; list[list[T]]:\n    length_counts = Counter((len(sub_lst) for sub_lst in lst))\n    return sorted(lst, key=lambda sub_lst: length_counts[len(sub_lst)])\n</code></pre>","tags":["List","Intermediate"]},{"location":"problems/p29_is_prime/","title":"Is Prime","text":"<p>Determine if a given integer number is prime</p> TestDirect <pre><code>def test_is_prime(solution):\n    assert solution(0) == False\n    assert solution(1) == False\n    assert solution(2) == True\n    assert solution(3) == True\n    assert solution(5) == True\n    assert solution(7) == True\n    assert solution(13) == True\n    assert solution(1299827) == True\n    assert solution(6) == False\n    assert solution(1000000) == False\n</code></pre> <pre><code>def is_prime_v1(num: int) -&gt; bool:\n    if num &lt;= 1: return False\n    if num == 2: return True\n    if num % 2 == 0: return False\n\n    upper_limit = isqrt(num)\n    odd_numbers = range(3, upper_limit + 1, 2)\n    return all((num % i != 0 for i in odd_numbers))\n</code></pre>","tags":["Arithmetic","Intermediate"]},{"location":"problems/p30_gcd/","title":"GCD","text":"<p>Determine the greatest common divisor of 2 positive integer numbers</p> <p> TestRecursiveIterativeDirect <pre><code>def test_gcd(solution):\n    assert solution(13, 27) == 1\n    assert solution(24, 18) == 6\n    assert solution(20536, 7826) == 2\n</code></pre> <pre><code>def gcd_v1(a: int, b: int) -&gt; int:\n    return a if b == 0 else gcd_v1(b, a % b)\n</code></pre> <pre><code>def gcd_v2(a: int, b: int) -&gt; int:\n    target, divider = a, b\n\n    while (remaining := target % divider) != 0:\n        target = divider\n        divider = remaining\n\n    return divider\n</code></pre> <pre><code>from math import gcd\n\ndef gcd_v3(a: int, b: int) -&gt; int:\n    return gcd(a, b)\n</code></pre>","tags":["Arithmetic","Intermediate"]},{"location":"problems/p31_prime_factors/","title":"Prime Factors","text":"<p>Construct a list containing the prime factors in ascending order for given integer.</p> TestRecursiveGeneratorIterativeWheel <pre><code>def test_prime_factors(solution):\n    assert solution(1) == []\n    assert solution(2) == [2]\n    assert solution(3) == [3]\n    assert solution(315) == [3, 3, 5, 7]\n    assert solution(9999) == [3, 3, 11, 101]\n    assert solution(1009899) == [3, 3, 11, 101, 101]\n    assert solution(99999) == [3, 3, 41, 271]\n</code></pre> <pre><code>def prime_factors_v1(m: int) -&gt; list[int]:\n    def aux(factors: list[int], curr_num: int, target: int) -&gt; list[int]:\n        if target == 1:\n            return factors\n        elif target % curr_num == 0:\n            return aux(factors + [curr_num], curr_num, target // curr_num)\n        else:\n            return aux(factors, curr_num + 1, target)\n\n    if m &lt;= 1: return []\n    return aux([], 2, m)\n</code></pre> <pre><code>from math import isqrt\nfrom typing import Generator\n\ndef prime_factors_v2(m: int) -&gt; list[int]:\n    def prime_factors_iter(target: int) -&gt; Generator[int]:\n        if target &lt;= 1:\n            return\n\n        nums_range = chain([2], range(3, isqrt(m) + 1, 2))\n        while curr_num := next(nums_range, None):\n            while target % curr_num == 0:\n                target //= curr_num\n                yield curr_num\n\n        if target != 1: yield target\n\n    return list(prime_factors_iter(m))\n</code></pre> <pre><code>from math import isqrt\n\ndef prime_factors_v3(m: int) -&gt; list[int]:\n    if m &lt;= 1: return []\n\n    factors = []\n\n    for curr_num in chain([2], range(3, isqrt(m) + 1, 2)):\n        while m % curr_num == 0:\n            factors.append(curr_num)\n            m //= curr_num\n\n    if m != 1: factors.append(m)\n    return factors\n</code></pre> <pre><code>from math import isqrt\nfrom typing import Generator\n\ndef prime_factors_v4(m: int) -&gt; list[int]:\n    if m &lt;= 1: return []\n\n    def tiny_wheel() -&gt; Generator[int]:\n        candiate = 5\n        gap_cycle = cycle([2, 4])\n\n        while True:\n            yield candiate\n            candiate += next(gap_cycle)\n\n    factors = []\n    all_candiates = chain([2, 3], tiny_wheel())\n\n    while (curr_num := next(all_candiates)) &lt;= isqrt(m):\n        while m % curr_num == 0:\n            factors.append(curr_num)\n            m //= curr_num\n\n    if m != 1: factors.append(m)\n    return factors\n</code></pre>","tags":["Arithmetic","Intermediate"]},{"location":"problems/p32_prime_factor_multiplicity/","title":"Prime Factor Multiplicity","text":"<p>Same as find the prime factors but instead return their counts. </p> TestRecursiveCompounding Previous Solutions <pre><code>def test_prime_factor_multiplicity(solution):\n    assert solution(1) == []\n    assert solution(315) == [(3, 2), (5, 1), (7, 1)]\n    assert solution(9999) == [(3, 2), (11, 1), (101, 1)]\n    assert solution(1009899) == [(3, 2), (11, 1), (101, 2)]\n    assert solution(99999) == [(3, 2), (41, 1), (271, 1)]\n</code></pre> <pre><code>from math import isqrt\nfrom itertools import chain\n\ntype FactorCount = tuple[int, int]\n\ndef prime_factor_counts_v1(target: int) -&gt; list[FactorCount]:\n    if target &lt;= 1: return []\n\n    accumulated = []\n    for curr_num in chain([2], range(3, isqrt(target) + 1, 2)):\n        curr_count = 0\n        while target % curr_num == 0:\n            curr_count += 1\n            target //= curr_num\n\n        if curr_count != 0:\n            accumulated.append((curr_num, curr_count))\n\n    if target != 1: \n        last_num, last_count = accumulated[-1]\n        if last_num != target:\n            accumulated.append((target, 1))\n        else:\n            accumulated[-1] = (last_num, last_count + 1)\n\n    return accumulated\n</code></pre> <pre><code>from solutions.p31_prime_factors import prime_factors_v4\nfrom solutions.p09_run_length_encoding import rle_encode_v3\n\ndef prime_factor_counts_v2(m: int) -&gt; list[FactorCount]:\n    factors = prime_factors_v4(m)\n    return rle_encode_v3(factors)\n</code></pre>","tags":["Arithmetic","Intermediate"]},{"location":"problems/p33_totient_function/","title":"Totient Function","text":"<p>Euler's Totient Function \u03c6(m) -&gt; number of positive integers that are coprime to m. Two numbers are coprime if their GCD is 1. </p> <p>If we know the prime factors and the multiplicities -&gt; [(p1, m1), (p2, m2), (p3, m3), ...]</p> <p>\u03c6(m) = (p1 - 1) \u00d7 p1^(m1 - 1) \u00d7 (p2 - 1) \u00d7 p2^(m2 - 1) \u00d7 (p3 - 1) \u00d7 p3^(m3 - 1) \u00d7 \u22ef</p> TestDirectFormula <pre><code>def test_totient_fn(solution):\n    assert solution(10) == 4\n    assert solution(20) == 8\n    assert solution(40) == 16\n    assert solution(99) == 60\n    assert solution(33) == 20\n    assert solution(1) == 1\n</code></pre> <pre><code>from math import gcd\n\ndef totient_fn_v1(m: int) -&gt; int:\n    if m == 1: return 1\n\n    return sum(1 if gcd(m, curr_num) == 1 else 0\n               for curr_num in range(1, m))\n</code></pre> <pre><code>from functools import reduce\nfrom operator import mul\nfrom solutions.p32_prime_factor_multiplicity import prime_factor_counts_v2\n\ndef totient_fn_v2(m: int) -&gt; int:\n    if m == 1: return 1\n\n    prime_counts = prime_factor_counts_v2(m)\n    return reduce(mul, [(p - 1) * p**(c - 1) \n                        for p, c in prime_counts])\n</code></pre>","tags":["Arithmetic","Intermediate"]},{"location":"problems/p34_goldbach_conjecture/","title":"Goldbach's Conjecture","text":"<p>Goldbach's conjecture says that every postive even number &gt; 2 is the sum of two primes.</p> TestRecursiveSieve/2Sum <pre><code>def test_goldbach_conjecture(solution):\n    assert sum(solution(4)) == sum((2, 2))\n    assert sum(solution(28)) == sum((5, 23))\n    assert sum(solution(32)) == sum((3, 29))\n    assert sum(solution(36)) == sum((7, 29))\n    assert solution(35) is None\n</code></pre> <pre><code>from solutions.p29_is_prime import is_prime_v1\n\ndef goldbach_v1(target: int) -&gt; tuple[int, int] | None:\n    if target &lt; 2 or target % 2 != 0:\n        return None\n\n    def aux(current_num: int) -&gt; tuple[int, int]:\n        if is_prime_v1(current_num) and is_prime_v1(target - current_num):\n            return (current_num, target - current_num)\n        else:\n            return aux(current_num + 1)\n\n    return aux(2)\n</code></pre> <pre><code>def goldbach_v2(target: int) -&gt; tuple[int, int] | None:\n    if target &lt; 2 or target % 2 != 0:\n        return None\n\n    def sieve(target: int) -&gt; list[int]:\n        possible_primes = dict.fromkeys(range(3, target + 1, 2))\n        primes = [2]\n        while possible_primes:\n            curr_prime = next(iter(possible_primes))\n            primes.append(curr_prime)\n            possible_primes.pop(curr_prime)\n\n            k = 1\n            while (eliminated := curr_prime * (2 * k + 1)) &lt; target:\n                possible_primes.pop(eliminated, None)\n                k += 1\n\n        return primes\n\n    def twosum(target: int, items: list[int]) -&gt; tuple[int, int] | None:\n        left, right = 0, len(items) - 1\n        while left &lt;= right:\n            left_item, right_item = items[left], items[right]\n            curr_sum = left_item + right_item\n\n            if curr_sum == target: return (left_item, right_item)\n            elif curr_sum &lt; target: left += 1\n            else: right -= 1\n\n        return None\n\n    primes = sieve(target)\n    return twosum(target, primes)\n</code></pre>","tags":["Arithmetic","Intermediate"]},{"location":"problems/p35_calculate_truth_table/","title":"Calculate Truth Table","text":"<p>Construct a function which returns the truth table of a given expression. The expression may contain any number of logical variables. The output is a list of TableRow where TableRow is      ((A, value of A), (B, value of B), (C, value of C), ..., expression value)</p> TestRecursive <pre><code>def test_calculate_truth_table(solution):\n    # A \u2229 (A \u222a B )\n    assert set(solution(['a', 'b'], And(Var('a'), Or(Var('a'), Var('b'))))) == set((\n        ((('a', 0), ('b', 0)), 0),\n        ((('a', 0), ('b', 1)), 0),\n        ((('a', 1), ('b', 0)), 1),\n        ((('a', 1), ('b', 1)), 1)\n    ))\n\n    # \u00ac(A \u2229 B)\n    assert set(solution(['a', 'b'], Not(And(Var('a'), Var('b'))))) == set((\n        ((('a', 0), ('b', 0)), 1),\n        ((('a', 0), ('b', 1)), 1),\n        ((('a', 1), ('b', 0)), 1),\n        ((('a', 1), ('b', 1)), 0)\n    ))\n\n    # \u00acA\n    assert set(solution(['a'], Not(Var('a')))) == set((\n        ((('a', 0),), 1),\n        ((('a', 1),), 0),\n    ))\n\n    # C \u222a (A \u2229 B)\n    assert set(solution(['a', 'b', 'c'], Or(Var('c'), Not(And(Var('a'), Var('b')))))) == set((\n        ((('a', 0), ('b', 0), ('c', 0)), 1),\n        ((('a', 0), ('b', 0), ('c', 1)), 1),\n        ((('a', 0), ('b', 1), ('c', 0)), 1),\n        ((('a', 0), ('b', 1), ('c', 1)), 1),\n        ((('a', 1), ('b', 0), ('c', 0)), 1),\n        ((('a', 1), ('b', 0), ('c', 1)), 1),\n        ((('a', 1), ('b', 1), ('c', 0)), 0),\n        ((('a', 1), ('b', 1), ('c', 1)), 1)\n    ))\n\ndef test_discover_vars():\n    # C \u222a (A \u2229 B) has 3 variables A, B, C\n    assert discover_vars(Or(Var('c'), Not(And(Var('a'), Var('b'))))) == {'a', 'b', 'c'}\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\nfrom itertools import product\n\n@dataclass\nclass Var:\n    name: str\n\n@dataclass\nclass Not:\n    expr: BoolExpr\n\n@dataclass\nclass And:\n    left: BoolExpr\n    right: BoolExpr\n\n@dataclass\nclass Or:\n    left: BoolExpr\n    right: BoolExpr\n\ntype BoolExpr = Var | Not | And | Or\ntype TableVar = tuple[str, bool]\ntype TableRow = tuple[tuple[TableVar], bool]\n\ndef calculate_truth_table_v1(vars: list[str], expr: BoolExpr) -&gt; tuple[TableRow]:\n    def eval_expr(expr: BoolExpr, values: dict[Var, bool]) -&gt; bool:\n        match expr:\n            case Var(name):\n                return values[name]\n            case Not(subexpr):\n                return not eval_expr(subexpr, values)\n            case And(left, right):\n                return eval_expr(left, values) and eval_expr(right, values)\n            case Or(left, right):\n                return eval_expr(left, values) or eval_expr(right, values)\n\n    res = []\n    for var_values in product([0, 1], repeat=len(vars)):\n        var_table = {var: val for var, val in zip(vars, var_values)}\n        res.append((tuple(var_table.items()), \n                    eval_expr(expr, var_table)))\n\n    return tuple(res)\n\n\ndef discover_vars(expr: BoolExpr) -&gt; set[str]:\n    match expr:\n        case Var(a): return {a}\n        case Not(a): return discover_vars(a)\n        case And(a, b) | Or(a, b): return discover_vars(a) | discover_vars(b)\n</code></pre>","tags":["Logic","Intermediate"]},{"location":"problems/p36_gray_code/","title":"Gray Code","text":"<p>An n-bit gray code is a sequence of n-bit strings where each string differs by only 1 bit as the sequence carries on.</p> <p>There is an exact formula as well.</p> TestRecursiveFormula <pre><code>def test_generate_gray_code(solution):\n    assert solution(1) == ['0', '1']\n    assert solution(2) == ['00', '01', '11', '10']\n    assert solution(3) == ['000', '001', '011', '010', '110', '111', '101', '100']\n</code></pre> <pre><code>def generate_gray_code_v1(bit_str_size: int) -&gt; list[str]:\n    match bit_str_size:\n        case 1: return ['0', '1']\n        case _:\n            prev_level_codes = generate_gray_code_v1(bit_str_size - 1)\n            p1 = (f'{a}{b}' for a,b in zip(repeat('0'), prev_level_codes))\n            p2 = (f'{a}{b}' for a,b in zip(repeat('1'), reversed(prev_level_codes)))\n            return list(chain(p1, p2))\n</code></pre> <pre><code>def generate_gray_code_v2(bit_str_size: int) -&gt; list[str]:\n    return [(bin(i ^ (i &gt;&gt; 1))[2:]).rjust(bit_str_size, \"0\")\n             for i in range(2**bit_str_size)]\n</code></pre>","tags":["Logic","Intermediate"]},{"location":"problems/p37_shannon_fano_encoding/","title":"Shannon Fano Encoding","text":"<p>Given an alphabet (a, b, c, d, ...) and their respective frequencies (45, 13, 12, ...). Construct a code C for every symbol S in the alphabet, [(symbol, code), ...] using Shannon Fano Encoding. </p> <p>Includes Shannon Fano encoding explanation</p> <p>Encoding calculator</p> TestRecursive <pre><code>def test_generate_shannon_fano_encoding(solution):\n    assert solution([\n        (\"a\", 45), (\"b\", 13), (\"c\", 12), \n        (\"d\", 16), (\"e\", 9), (\"f\", 5)\n    ]) == [\n        ('a', '0'), ('d', '100'), ('b', '101'),\n        ('c', '110'), ('e', '1110'), ('f', '1111')]\n\n    assert solution([\n        ('a', 100), ('b', 1), ('c', 1)\n    ]) == [\n        ('a', '0'), ('b', '10'), ('c', '11')]\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\nfrom bisect import bisect\nfrom itertools import accumulate\n\n@dataclass\nclass Leaf:\n    symbol: str\n\n@dataclass\nclass Branch:\n    left: Tree\n    right: Tree\n\ntype Tree = Branch | Leaf | None\ntype SymbolFrequency = tuple[str, int]\ntype Code = tuple[str, str]\n\n\ndef generate_shannon_fano_encoding_v1(alphabet: list[SymbolFrequency]) -&gt; list[Code]:\n    def find_best_split_point(alphabet: list[SymbolFrequency]) -&gt; int:\n        cumulative_sums = [0] + list(accumulate(elem[1] for elem in alphabet))\n        ideal_midpoint = cumulative_sums[-1] / 2.0\n        insertion_point = bisect(cumulative_sums, ideal_midpoint)\n\n        diff_at = abs(cumulative_sums[insertion_point] - ideal_midpoint)\n        diff_right_before = abs(cumulative_sums[insertion_point - 1] - ideal_midpoint)\n\n        if diff_at &lt; diff_right_before: return insertion_point\n        else: return insertion_point - 1\n\n    def contruct_tree(alphabet: list[SymbolFrequency]) -&gt; Tree:\n        match alphabet:\n            case []: return None\n            case [a]: return Leaf(a[0])\n            case _:\n                split_point = find_best_split_point(alphabet)\n                left, right = alphabet[:split_point], alphabet[split_point:]\n                return Branch(contruct_tree(left), contruct_tree(right))\n\n    def calculate_codes(tree: Tree, current_path: str) -&gt; list[Code]:\n        match tree:\n            case None: return []\n            case Leaf(symbol): return [(symbol, current_path)]\n            case Branch(left, right):\n                return calculate_codes(left, current_path + \"0\") + calculate_codes(right, current_path + \"1\")\n\n    sorted_alphabet = sorted(alphabet, key=lambda elem: elem[1], reverse=True)\n    encoding_tree = contruct_tree(sorted_alphabet)\n    return calculate_codes(encoding_tree, \"\")\n</code></pre>","tags":["Logic","Intermediate"]},{"location":"problems/p38_huffman_encoding/","title":"Huffman Encoding","text":"<p>Given an alphabet (a, b, c, d, ...) and their respective frequencies (45, 13, 12, ...). Construct a code C for every symbol S in the alphabet, [(symbol, code), ...] using Huffman Encoding.</p> <p>Encoding calculator</p> TestIterative <pre><code>def test_generate_huffman_encoding(solution):\n    assert solution([\n        (\"a\", 45), (\"b\", 13), (\"c\", 12), \n        (\"d\", 16), (\"e\", 9), (\"f\", 5)\n    ]) == [\n        (\"a\", \"0\"), (\"c\", \"100\"), (\"b\", \"101\"), \n        (\"f\", \"1100\"), (\"e\", \"1101\"), (\"d\", \"111\")]\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\nfrom sortedcontainers import SortedList\n\n@dataclass\nclass Leaf:\n    symbol: str\n    value: int\n\n@dataclass\nclass Branch:\n    value: int\n    left: Tree\n    right: Tree\n\ntype Tree = Leaf | Branch | None\n\ntype SymbolFrequency = tuple[str, int]\ntype Code = tuple[str, str]\n\ndef generate_huffman_codes_v1(alphabet: list[SymbolFrequency]) -&gt; list[Code]:\n    def contruct_encoding_tree(alphabet: list[SymbolFrequency]) -&gt; Tree:\n        if len(alphabet) == 0: return None\n        if len(alphabet) == 1: return Leaf(alphabet[0][0], alphabet[0][1])\n\n        leaves = [Leaf(sym, val) for sym, val in alphabet]\n        trees = SortedList(leaves, key=lambda t: t.value)\n\n        while len(trees) &gt; 1:\n            lowest_occurring = trees.pop(0)\n            next_lowest_occurring = trees.pop(0)\n            new_tree = Branch(lowest_occurring.value + next_lowest_occurring.value, \n                              lowest_occurring,\n                              next_lowest_occurring)\n            trees.add(new_tree)\n\n        return trees.pop(0)\n\n    def calculate_codes(encoding_tree: Tree, current_path: str) -&gt; list[Code]:\n        match encoding_tree:\n            case None: return []\n            case Leaf(sym, _): return [(sym, current_path)]\n            case Branch(_, left, right):\n                return calculate_codes(left, current_path + \"0\") + calculate_codes(right, current_path + \"1\")\n\n    encoding_tree = contruct_encoding_tree(alphabet)\n    return calculate_codes(encoding_tree, \"\")\n</code></pre>","tags":["Logic","Advanced"]},{"location":"problems/p39_generate_completely_balanced_binary_trees/","title":"Completely Balanced Binary Trees","text":"<p>A binary tree is either empty or it is made of a root element an 2 successors. The successors are binary trees. A completely balanced binary tree is a tree where the number of nodes on the left \\(N_L\\) and the number of nodes on the right \\(N_R\\)  differ by at most 1 so \\(|N_L - N_R| \\leq 1\\). </p> <p>Generate all completely balanced binary trees for a given number of nodes. Put the letter 'x' as information into all nodes of the tree.</p> <pre><code>graph TD\n    subgraph Binary Tree\n        A1(x) --&gt; B1(x)\n        A1(x) --&gt; C1(x)\n        B1(x) --&gt; D1(x)\n        B1(x) --&gt; E1(x)\n        C1(x) --&gt; F1(x)\n        F1(x) --&gt; G1(x)\n    end\n\n    subgraph Completely Balanced Binary Tree\n        A2(x) --&gt; B2(x)\n        A2(x) --&gt; C2(x)\n        B2(x) --&gt; D2(x)\n        B2(x) --&gt; E2(x)\n        C2(x) --&gt; F2(x)\n    end</code></pre> TestRecursive <pre><code>def test_generate_trees(solution):\n    assert solution(0) == [None]\n\n    assert solution(4) == [\n        Node(left=Node(left=None, right=None, value='x'), right=Node(left=None, right=Node(left=None, right=None, value='x'), value='x'), value='x'),\n        Node(left=Node(left=None, right=None, value='x'), right=Node(left=Node(left=None, right=None, value='x'), right=None, value='x'), value='x'),\n        Node(left=Node(left=None, right=Node(left=None, right=None, value='x'), value='x'), right=Node(left=None, right=None, value='x'), value='x'),\n        Node(left=Node(left=Node(left=None, right=None, value='x'), right=None, value='x'), right=Node(left=None, right=None, value='x'), value='x')\n    ]\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\nfrom itertools import product\nfrom functools import cache\n\n\n@dataclass\nclass Node:\n    left: Tree\n    right: Tree\n    value: str = 'x'\n\ntype Tree = Node | None\n\n@cache\ndef generate_completely_balanced_binary_trees_v1(nodes: int) -&gt; list[Tree]:\n    match nodes:\n        case 0: \n            return [None]\n\n        case 1: \n            return [Node(None, None)]\n\n        case n if (remaining_nodes := n - 1) % 2 == 0:\n            subtrees = generate_completely_balanced_binary_trees_v1(remaining_nodes // 2)\n            return [Node(left, right) for left, right in product(subtrees, subtrees)]\n\n        case n if (remaining_nodes := n - 1) % 2 == 1:\n            smaller_subtrees = generate_completely_balanced_binary_trees_v1(remaining_nodes // 2)\n            larger_subtrees = generate_completely_balanced_binary_trees_v1(remaining_nodes // 2 + 1)\n\n            p1_trees = [Node(left, right) for left, right in product(smaller_subtrees, larger_subtrees)]\n            p2_trees = [Node(left, right) for left, right in product(larger_subtrees, smaller_subtrees)]\n\n            return p1_trees + p2_trees\n</code></pre>","tags":["Tree","Intermediate"]},{"location":"problems/p40_symmetric_binary_trees/","title":"Symmetric Binary Trees","text":"<p>A binary tree is symmetric if you can draw a vertical (horizontal if you look at the diagram) line through the root node and the right subtree \\(R_T\\) is a mirror image of the left subtree \\(L_T\\). We are only interested in the structure and not content of nodes.</p> <pre><code>graph TD\n    subgraph Symmetric\n        A1(x) --&gt; B1(x)\n        A1(x) --&gt; C1(x)\n        B1(x) --&gt; E1(x)\n        B1(x) --&gt; D1(\u2205)\n        C1(x) --&gt; G1(\u2205)\n        C1(x) --&gt; F1(x)\n    end\n\n    subgraph Not Symmetric\n        A2(x) --&gt; B2(x)\n        A2(x) --&gt; C2(x)\n        B2(x) --&gt; E2(x)\n        B2(x) --&gt; D2(\u2205)\n        C2(x) --&gt; G2(x)\n        C2(x) --&gt; F2(\u2205)\n    end\n\n    classDef nullNode fill:#eee,stroke:#999,stroke-dasharray: 5 5,color:#666\n    class D1,G1,D2,F2 nullNode</code></pre> TestRecursiveRecursive with Helper <pre><code>def test_is_symmetric_tree(solution):\n    assert solution(Branch(None, None)) == True\n    assert solution(Branch(Branch(None, Branch(None, None)), \n                           Branch(Branch(None, None), None))) == True\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\n\n@dataclass\nclass Branch:\n    left: Tree\n    right: Tree\n\ntype Tree = Branch | None\n\ndef is_symmetric_tree_v1(tree: Tree) -&gt; bool:\n    match tree:\n        case None: \n            return True\n\n        case Branch(None, None): \n            return True\n\n        case Branch(_, None) | Branch(None, _): \n            return False\n\n        case Branch(left_tree, right_tree):\n            return is_symmetric_tree_v1(Branch(left_tree.left, right_tree.right)) and\\\n                   is_symmetric_tree_v1(Branch(left_tree.right, right_tree.left))\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\n\n@dataclass\nclass Branch:\n    left: Tree\n    right: Tree\n\ntype Tree = Branch | None\n\ndef is_symmetric_tree_v2(tree: Tree) -&gt; bool:\n    def is_mirror(left_tree: Tree, right_tree: Tree) -&gt; bool:\n        match (left_tree, right_tree):\n            case (None, None): \n                return True\n\n            case (_, None) | (None, _): \n                return False\n\n            case (Branch(lt_left, lt_right), Branch(rt_left, rt_right)):\n                return is_mirror(lt_left, rt_right) and is_mirror(lt_right, rt_left)\n\n\n    if tree is None: return True\n    return is_mirror(tree.left, tree.right)\n</code></pre>","tags":["Tree","Intermediate"]},{"location":"problems/p41_bst/","title":"Binary Search Tree","text":"<p>Construct a BST (binary search tree) from a list of integer numbers.</p> <pre><code>graph TD\n    subgraph BST for [3, 2, 5, 7, 1]\n        A(3) --&gt; B(2)\n        A(3) --&gt; C(5)\n\n        B(2) --&gt; D(1)\n        B(2) --&gt; E(\u2205)\n\n        C(5) --&gt; F(\u2205)\n        C(5) --&gt; G(7)\n\n        D(1) --&gt; H(\u2205)\n        D(1) --&gt; I(\u2205)\n\n        G(7) --&gt; J(\u2205)\n        G(7) --&gt; K(\u2205)\n    end\n\n    classDef nullNode fill:#f9f9f9,stroke:#ddd,stroke-dasharray: 4 4,color:#aaa\n    class E,F,H,I,J,K nullNode</code></pre> TestRecursiveRecursive/No Mutation <pre><code>def test_construct_bst(solution):\n    assert solution([3, 2, 5, 7, 1]) == Node(3, \n                                             Node(2, Node (1, None, None), \n                                                     None), \n                                             Node(5, None, \n                                                     Node (7, None, None)))\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\n\n@dataclass\nclass Node:\n    value: int\n    left: Tree\n    right: Tree\n\ntype Tree = Node | None\n\ndef construct_bst_v1(lst: list[int]) -&gt; Tree:\n    if len(lst) == 0: return None\n\n    def insert_into_bst(tree: Tree, num_to_insert: int):\n        match tree:\n            case Node(val, None, _) if num_to_insert &lt; val:\n                tree.left = Node(num_to_insert, None, None)\n\n            case Node(val, _, None) if num_to_insert &gt;= val:\n                tree.right = Node(num_to_insert, None, None)\n\n            case Node(val, lt, rt) if num_to_insert &lt; val:\n                insert_into_bst(lt, num_to_insert)\n\n            case Node(val, lt, rt) if num_to_insert &gt;= val:\n                insert_into_bst(rt, num_to_insert)\n\n    t = Node(lst[0], None, None)\n    for elem in lst[1:]:\n        insert_into_bst(t, elem)\n\n    return t\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\nfrom functools import reduce\n\n@dataclass\nclass Node:\n    value: int\n    left: Tree\n    right: Tree\n\ntype Tree = Node | None\n\ndef construct_bst_v2(lst: list[int]) -&gt; Tree:\n    def insert_into_bst(tree: Tree, num_to_insert: int) -&gt; Tree:\n        match tree:\n            case None:\n                return Node(num_to_insert, None, None)\n\n            case Node(val, None, rt) if num_to_insert &lt; val:\n                new_lt = Node(num_to_insert, None, None)\n                return Node(val, new_lt, rt)\n\n            case Node(val, lt, None) if num_to_insert &gt;= val:\n                new_rt = Node(num_to_insert, None, None)\n                return Node(val, lt, new_rt)\n\n            case Node(val, lt, rt) if num_to_insert &lt; val:\n                new_lt = insert_into_bst(lt, num_to_insert)\n                return Node(val, new_lt, rt)\n\n            case Node(val, lt, rt) if num_to_insert &gt;= val:\n                new_rt = insert_into_bst(rt, num_to_insert)\n                return Node(val, lt, new_rt)\n\n    return reduce(insert_into_bst, lst, None)\n</code></pre>","tags":["Tree","Intermediate"]},{"location":"problems/p42_generate_height_balanced_binary_trees/","title":"Generate Height Balanced Trees","text":"<p>In a height balanced tree, the height of the left subtree \\(T_L\\) and the height of the right subtree differe by no more than 1. </p> <p>\\(H_L\\) and \\(H_R\\) are the heights of \\(T_L\\) and \\(T_R\\) respectively. \\(|H_L - H_R| \u2264 1\\)</p> <p>Generate all possible height balanced trees for height \\(H\\)</p> TestRecursive <pre><code>def test_generate_height_balanced_binary_trees(solution):\n    assert len(solution(2)) == 3\n    assert len(solution(3)) == 15\n    assert len(solution(4)) == 315\n    assert len(solution(5)) == 108675\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\nfrom itertools import product\nfrom functools import cache\n\n@dataclass(frozen=True)\nclass Node:\n    left: Tree\n    right: Tree\n    value: str = 'x'\n\ntype Tree = Node | None\n\n@cache\ndef generate_height_balanced_trees_v1(height: int) -&gt; list[Tree]:\n    match height:\n        case 0: return [None]\n        case 1: return [Node(None, None)]\n        case h:\n            k = h - 1\n            subtrees = generate_height_balanced_trees_v1(k)\n            shorter_subtrees = generate_height_balanced_trees_v1(k - 1)\n\n            p1 = [Node(left, right) for left, right in product(subtrees, subtrees)]\n            p2 = [Node(left, right) for left, right in product(subtrees, shorter_subtrees)]\n            p3 = [Node(left, right) for left, right in product(shorter_subtrees, subtrees)]\n\n            return p1 + p2 + p3\n</code></pre>","tags":["Tree","Intermediate"]},{"location":"problems/p43_generate_height_balanced_binary_trees_given_nodes/","title":"Generate Height Balanced Trees With a Given Number of Nodes","text":"<p>Given \\(N\\) nodes, generate all height balanced trees with exactly \\(N\\) nodes.</p> TestRecursive <pre><code>def test_generate_height_balanced_binary_trees_given_nodes(solution):\n    assert len(solution(0)) == 1\n    assert len(solution(1)) == 1\n    assert len(solution(2)) == 2\n    assert len(solution(3)) == 1\n    assert len(solution(4)) == 4\n    assert len(solution(5)) == 6\n    assert len(solution(15)) == 1553\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\nfrom functools import cache\nfrom math import log2, ceil, floor\nfrom itertools import product, chain\n\n@dataclass(frozen=True)\nclass Node:\n    left: Tree\n    right: Tree\n    value: str = 'x'\n\ntype Tree = Node | None\n\ndef generate_height_balanced_trees_given_nodes_v1(nodes: int) -&gt; list[Tree]:\n\n    @cache\n    def minimum_nodes(height: int) -&gt; int:\n        if height == 0: return 0\n        if height == 1: return 1\n        return minimum_nodes(height - 1) + minimum_nodes(height - 2) + 1\n\n    def maximum_nodes(height: int) -&gt; int:\n        return 2**height - 1\n\n    def minimum_height(nodes: int) -&gt; float:\n        return log2(nodes + 1)\n\n    def maximum_height(n: int) -&gt; int:\n        h = 0\n        while minimum_nodes(h + 1) &lt;= n:\n            h += 1\n        return h\n\n    @cache\n    def generate_trees(nodes: int, height: int) -&gt; list[Tree]:\n        match (nodes, height):\n            case (0, 0): return [None]\n            case (1, 1): return [Node(None, None)]\n            case (0, _) | (_, 0): return []\n            case (n, h) if (n &lt; minimum_nodes(h)): return []\n            case (n, h) if (n &gt; maximum_nodes(h)): return []\n            case _:\n                k = height - 1 # Remaining height excluding the root\n                n = nodes - 1  # Remaining nodes excluding the root\n\n                partitions = [(k, k), (k - 1, k), (k, k - 1)]\n                total_trees = []\n\n                for left_height, right_height in partitions:\n                    min_nodes = minimum_nodes(left_height)\n                    max_nodes = maximum_nodes(left_height)\n\n                    for curr_node_amount in range(min_nodes, max_nodes + 1):\n                        left_tree_node_amount = curr_node_amount\n                        right_tree_node_amount = n - curr_node_amount # The total number of nodes must add up across the subtrees\n\n                        left_trees = generate_trees(left_tree_node_amount, left_height)\n                        right_trees = generate_trees(right_tree_node_amount, right_height)\n\n                        cross_trees = (Node(left, right) for left, right in product(left_trees, right_trees))\n                        total_trees.append(cross_trees)\n\n                return list(chain(*total_trees))\n\n    min_height = ceil(minimum_height(nodes))\n    max_height = floor(maximum_height(nodes))\n\n    return list(chain(*(generate_trees(nodes, h) \n                        for h in range(min_height, max_height + 1))))\n</code></pre>","tags":["Tree","Intermediate"]},{"location":"problems/p44_generate_complete_binary_tree/","title":"Generate Complete Binary Tree","text":"<p>A complete binary tree (CBT) cannot have holes in any level above the last one. A CBT is left-adjusted so all nodes are packed to the left w/o gaps. Generate a CBT given \\(N\\) nodes.</p> <pre><code>graph TD\n    A(1) --&gt; B(2)\n    A(1) --&gt; C(3)\n\n    B(2) --&gt; D(4)\n    B(2) --&gt; E(5)\n\n    C(3) --&gt; F(6)\n    C(3) --&gt; G(7)\n\n    D(4) --&gt; H(8)\n    D(4) --&gt; I(9)\n\n    E(5) --&gt; J(10)\n    E(5) --&gt; K(11)\n\n    F(6) --&gt; L(12)\n    F(6) --&gt; M(\u2205)\n\n    G(7) --&gt; N(\u2205)\n    G(7) --&gt; O(\u2205)\n\n    classDef nullNode fill:#f9f9f9,stroke:#ddd,stroke-dasharray: 4 4,color:#aaa\n    class M,N,O nullNode</code></pre> TestRecursive <pre><code>def is_cbt_v1(tree: Tree, num_of_nodes: int) -&gt; bool:\n    nodes = deque([])\n\n    if tree is not None: \n        nodes.append((tree, 1))\n\n    expected_address = 1\n    total_nodes_counted = 0\n\n    while nodes:\n        current_node, address = nodes.popleft()\n\n        if address != expected_address or total_nodes_counted &gt; num_of_nodes:\n            return False\n\n        expected_address += 1\n        total_nodes_counted += 1\n\n        if (left := current_node.left) is not None:\n            nodes.append((left, 2 * address))\n\n        if (right := current_node.right) is not None:\n            nodes.append((right, 2 * address + 1))\n\n    return total_nodes_counted == num_of_nodes\n\n\ndef test_generate_complete_binary_tree(solution):\n    assert is_cbt_v1(solution(0), 0)\n    assert is_cbt_v1(solution(1), 1)\n    assert is_cbt_v1(solution(2), 2)\n    assert is_cbt_v1(solution(3), 3)\n    assert is_cbt_v1(solution(8), 8)\n    assert is_cbt_v1(solution(17), 17)\n    assert is_cbt_v1(solution(17), 19) == False\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\n\n@dataclass\nclass Node:\n    left: Tree\n    right: Tree\n    value: str = 'x'\n\ntype Tree = Node | None\n\n\ndef generate_cbt_v1(n: int) -&gt; Tree:\n    def aux(n: int, address: int) -&gt; Tree:\n        match (n, address):\n            case _ if (right_tree_address := 2*address + 1) &lt;= n:\n                return Node(aux(n, right_tree_address - 1), aux(n, right_tree_address))\n\n            case _ if (left_tree_address := 2*address) &lt;= n:\n                return Node(aux(n, left_tree_address), None)\n\n            case _ if address &lt;= n:\n                return Node(None, None)\n\n    if n == 0: return None\n    return aux(n, 1)\n</code></pre>","tags":["Tree","Intermediate"]},{"location":"problems/p45_string_representation_of_binary_trees/","title":"Tree to String","text":"<p>Given a tree \\(T\\), convert it into string format. </p> <pre><code>\u2205 \u2192 ''\nN(\u2205, \u2205, a) \u2192 'a'\nN(N(\u2205, \u2205, b), \u2205, a) \u2192 'a(b,)'\nN(\u2205, N(\u2205, \u2205, c), a) \u2192 'a(,c)'\n</code></pre> <pre><code>---\ntitle: a(b(d,e),c(,f(g,)))\n---\n\ngraph TD\n    A(a) --&gt; B(b)\n    A(a) --&gt; C(c)\n\n    B(b) --&gt; D(d)\n    B(b) --&gt; E(e)\n\n    C(c) --&gt; NullC(\u2205)\n    C(c) --&gt; F(f)\n\n    F(f) --&gt; G(g)\n    F(f) --&gt; NullF(\u2205)\n\n    classDef nullNode fill:#f9f9f9,stroke:#ddd,stroke-dasharray: 4 4,color:#aaa\n    class NullC,NullF nullNode</code></pre> TestRecursive <pre><code>def test_tree_to_string(solution):\n    tree = Node('a', Node ('b', Node ('d', None, None), Node ('e', None, None)),\n                     Node ('c', None, Node ('f', Node ('g', None, None), None)))\n    assert solution(tree) == 'a(b(d,e),c(,f(g,)))'\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\n\n@dataclass\nclass Node:\n    value: str\n    left: Tree\n    right: Tree\n\ntype Tree = Node | None\n\ndef tree_to_string_v1(tree: Tree) -&gt; str:\n    match tree:\n        case None: return ''\n        case Node(value, None, None): return f'{value}'\n        case Node(value, left, right):\n            left_str = tree_to_string_v1(left)\n            right_str = tree_to_string_v1(right)\n            return f'{value}({left_str},{right_str})'\n</code></pre>","tags":["Tree","Intermediate"]},{"location":"problems/p46_string_to_tree/","title":"String to Tree","text":"<p>Given a string like 'a(b, c)' parse it into a tree.</p> TestRecursive <pre><code>def test_string_to_tree(solution):\n    tree = Node('a', Node ('b', Node ('d', None, None), Node ('e', None, None)),\n                        Node ('c', None, Node ('f', Node ('g', None, None), None)))\n    assert solution('a(b(d,e),c(,f(g,)))') == tree\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\n\n@dataclass\nclass Node:\n    value: str\n    left: Tree\n    right: Tree\n\ntype Tree = Node | None\n\ndef string_to_tree_v1(tree_str: str) -&gt; Tree:\n    def aux(idx: int) -&gt; tuple[Tree, int]:\n        if idx &gt;= len(tree_str) or tree_str[idx] in [',', ')']:\n            return None, idx\n\n        current_char = tree_str[idx]\n        next_char = tree_str[idx + 1]\n\n        match (current_char, next_char):\n            case (val, \"(\"):\n                left, left_final_idx = aux(idx + 2)\n                right, right_final_idx = aux(left_final_idx + 1)\n                return Node(val, left, right), right_final_idx + 1\n\n            case (\"(\", \",\"):\n                return None, idx\n\n            case (val, \",\") | (val, \")\"):\n                return Node(val, None, None), idx + 1\n\n    tree, _ = aux(0)    \n    return tree\n</code></pre>","tags":["Tree","Intermediate"]},{"location":"problems/p47_preorder_tree_traversal/","title":"Preorder Tree Traversal","text":"<p>Given a tree \\(T\\), output a string of its values via preorder traversal.</p> TestRecursive <pre><code>def test_preorder_tree_traversal(solution):\n    tree = string_to_tree_v1('a(b(d,e),c(,f(g,)))')\n    assert solution(tree) == 'abdecfg'\n</code></pre> <pre><code>def preorder_tree_traversal_v1(tree: Tree) -&gt; str:\n    match tree:\n        case None: \n            return ''\n        case Node(val, left, right): \n            return val + preorder_tree_traversal_v1(left) + preorder_tree_traversal_v1(right)\n</code></pre>","tags":["Tree","Intermediate"]},{"location":"problems/p48_inorder_tree_traversal/","title":"Inorder Traversal","text":"<p>Given a tree \\(T\\), output a string of its values via inorder traversal.</p> TestRecursive <pre><code>def test_inorder_tree_traversal(solution):\n    tree = string_to_tree_v1('a(b(d,e),c(,f(g,)))')\n    assert solution(tree) == 'dbeacgf'\n</code></pre> <pre><code>def inorder_tree_traversal_v1(tree: Tree) -&gt; str:\n    match tree:\n        case None: \n            return ''\n        case Node(val, left, right): \n            return inorder_tree_traversal_v1(left) + val + inorder_tree_traversal_v1(right)\n</code></pre>","tags":["Tree"]},{"location":"problems/p49_tree_from_inorder_preorder_sequence/","title":"Tree from inorder and preorder sequence","text":"<p>From a preorder and inorder tree traversal sequence, generate a tree \\(T\\).</p> TestRecursive <pre><code>def test_(solution):\n    tree = string_to_tree_v1('a(b(d,e),c(,f(g,)))')\n    assert solution('abdecfg', 'dbeacgf') == tree\n</code></pre> <pre><code>def tree_from_sequence_v1(preorder: str, inorder: str) -&gt; Tree:\n    if len(preorder) == 0 or len(inorder) == 0:\n        return None\n\n    root_node = preorder[0]\n    split_point = inorder.index(root_node)\n\n    left_inorder = inorder[:split_point]\n    right_inorder = inorder[split_point + 1:]\n\n    left_preorder = preorder[1: 1 + len(left_inorder)]\n    right_preorder = preorder[1 + len(left_inorder): ]\n\n    left_tree = tree_from_sequence_v1(left_preorder, left_inorder)\n    right_tree = tree_from_sequence_v1(right_preorder, right_inorder)\n\n    return Node(root_node, left_tree, right_tree)\n</code></pre>","tags":["Tree","Intermediate"]},{"location":"problems/p50_multiway_tree_to_string/","title":"Multiway Tree to String","text":"<p>A multiway tree has a root element and a list of multiway trees as successors. The nodes can contain any value. In this case, they will contain single characters. </p> <p>A special character ^ has been inserted during depth-first order traversal.  This means to backtrack to the previous level. </p> <p>Given a multiway tree, generate its string representation.</p> <pre><code>---\ntitle: afg^^c^bd^e^^^\n---\n\ngraph TD\n    A(a) --&gt; F(f)\n    A(a) --&gt; C(c)\n    A(a) --&gt; B(b)\n\n    F(f) --&gt; G(g)\n\n    B(b) --&gt; D(d)\n    B(b) --&gt; E(e)</code></pre> TestRecursive <pre><code>def test_tree_to_string(solution):\n    tree = Node('a', [Node('f', [Node('g', [])]),\n                      Node('c', [])])\n    assert solution(tree) == 'afg^^c^^'\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\n\n@dataclass\nclass Node:\n    value: str\n    successors: list[Tree]\n\ntype Tree = Node\n\n\ndef tree_to_string(tree: Tree) -&gt; str:\n    successors_str = ''.join(tree_to_string(st) for st in tree.successors)\n    return tree.value + successors_str + '^'\n</code></pre>","tags":["Tree","Intermediate"]},{"location":"problems/p51_multiway_tree_from_string/","title":"String to Multiway Tree","text":"<p>Given a string representation of a multiway tree, parse it and output a tree.</p> TestRecursive <pre><code>def test_tree_from_string(solution):\n    assert tree_to_string(solution('afg^^c^^')) == 'afg^^c^^'\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\n\n@dataclass\nclass Node:\n    value: str\n    successors: list[Tree]\n\ntype Tree = Node\n\ndef string_to_tree_v1(tree_str: str) -&gt; Tree | None:\n    def parse_node(idx: int) -&gt; tuple[Tree, int]:\n        val = tree_str[idx]\n        children, final_idx = parse_children(idx + 1)\n        return Node(val, children), final_idx\n\n    def parse_children(idx: int) -&gt; tuple[list[Tree], int]:\n        if idx &gt;= len(tree_str) or tree_str[idx] == '^':\n            return [], idx + 1\n\n        tree, next_idx = parse_node(idx)\n        children, final_idx = parse_children(next_idx)\n        return [tree] + children, final_idx\n\n    if len(tree_str) == 0: return None\n    tree, _ = parse_node(0)\n    return tree\n</code></pre>","tags":["Tree","Intermediate"]},{"location":"problems/p52_lispy_tree_representation/","title":"Lisp-Like Tree Representation","text":"<p>Given a multiway tree \\(T\\) output its lisp-like representation. A node with children is always the first in a list, followed by its children.  The lisp-like representation is a sequence composed of &lt;value&gt;  or  \"(\"  or  \")\"</p> <pre><code>---\ntitle: (a (b c))\n---\n\ngraph TD\n    T3_A(a) --&gt; T3_B(b)\n    T3_B(b) --&gt; T3_C(c)</code></pre> <pre><code>---\ntitle: (a (f g) c (b d e))\n---\n\ngraph TD\n    A(a) --&gt; F(f)\n    A(a) --&gt; C(c)\n    A(a) --&gt; B(b)\n\n    F(f) --&gt; G(g)\n\n    B(b) --&gt; D(d)\n    B(b) --&gt; E(e)</code></pre> TestRecursive <pre><code>def test_lispy_tree_representation(solution):\n    t = Node('a', [])\n    assert solution(t) == 'a'\n\n    t = Node('a', [Node('b', [])])\n    assert solution(t) == '(a b)'\n\n    t = Node('a', [Node('b', [Node('c', [])])])\n    assert solution(t) == '(a (b c))'\n\n    t = Node('a', [Node('b', []), Node('c', [])])\n    assert solution(t) == '(a b c)'\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\n\n@dataclass\nclass Node:\n    value: str\n    successors: list[Tree]\n\ntype Tree = Node\n\ndef lispy_tree_repr_v1(tree: Tree) -&gt; str:\n    match tree:\n        case Node(val, []): \n            return val\n\n        case Node(val, children):\n            children_repr = ' '.join(lispy_tree_repr_v1(child) for child in children)\n            return f'({val} {children_repr})'\n</code></pre>","tags":["Tree","Intermediate"]},{"location":"problems/p53_path_from_one_node_to_another/","title":"Path From One Node to Another One","text":"<p>Given a graph \\(G\\) in graph-term form. Find all paths from starting node \\(S\\) to final node \\(F\\). <pre><code>G \u2192 (Nodes, Edges) \u2192 ([b, c, d, f, g, h, k], [(h, g), (k, f), (f, b), (f, c), (c, b)])\n</code></pre></p> <pre><code>graph TD\n    subgraph Graph\n        h --&gt; g\n        k --&gt; f\n        f --&gt; b\n        f --&gt; c\n        c --&gt; b\n\n        d\n    end</code></pre> TestRecursiveGenerator <pre><code>def test_find_paths(solution):\n    g = Graph(['b', 'c', 'd', 'f', 'g', 'h', 'k'],\n              [Edge('h', 'g'), Edge('k', 'f'), Edge('f', 'b'), \n               Edge('f', 'c'), Edge('c', 'b')])\n\n    assert set(solution(g, 'f', 'b')) == set([('f', 'c', 'b'), ('f', 'b')])\n    assert set(solution(g, 'd', 'h')) == set([])\n    assert set(solution(g, 'h', 'g')) == set([('h', 'g')])\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\nfrom collections import namedtuple\n\nEdge = namedtuple('Edge', ['start', 'end'])\n\n@dataclass\nclass Graph[T]:\n    nodes: list[T]\n    edges: list[Edge]\n\n\ndef find_paths_v1[T](graph: Graph, start: T, end: T) -&gt; list[tuple[T]]:\n    valid_paths = []\n\n    def aux(curr_node: T, seen_nodes: set[T], curr_path: tuple[T]) -&gt; None:\n        if curr_node == end:\n            valid_paths.append(curr_path)\n            return\n\n        for edge in graph.edges:\n            if edge.start == curr_node and edge.end not in seen_nodes:\n                aux(edge.end, seen_nodes | {edge.end}, curr_path + (edge.end,))\n\n    aux(start, {start}, (start,))\n    return valid_paths\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\nfrom collections import namedtuple\nfrom typing import Generator\n\nEdge = namedtuple('Edge', ['start', 'end'])\n\n@dataclass\nclass Graph[T]:\n    nodes: list[T]\n    edges: list[Edge]\n\n\ndef find_paths_v2[T](graph: Graph, start: T, end: T) -&gt; list[tuple[T]]:\n    def aux(curr_node: T, seen_nodes: set[T], curr_path: tuple[T]) -&gt; Generator[tuple[T]]:\n        if curr_node == end:\n            yield curr_path\n            return\n\n        for edge in graph.edges:\n            if edge.start == curr_node and edge.end not in seen_nodes:\n                yield from aux(edge.end, seen_nodes | {edge.end}, curr_path + (edge.end,))\n\n    return list(aux(start, {start}, (start,)))\n</code></pre>","tags":["Graph","Intermediate"]},{"location":"problems/p54_generate_spanning_trees/","title":"Generate all Spanning Trees","text":"<p>Generate all the spanning trees of a given graph \\(G\\). A spanning tree contains all the nodes of \\(G\\) and a minimal set of edges from \\(G\\) without creating cycles.</p> TestRecursive <pre><code>def test_generate_spanning_trees(solution):\n    g = Graph(nodes = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],\n              edges = [Edge('a', 'b'), Edge('a', 'd'), Edge('b', 'c'), Edge('b', 'e'),\n                       Edge('c', 'e'), Edge('d', 'e'), Edge('d', 'f'), Edge('d', 'g'),\n                       Edge('e', 'h'), Edge('f', 'g'), Edge('g', 'h')])\n\n    assert len(solution(g)) == 112\n\n    g = Graph(nodes = ['a', 'b', 'c'],\n              edges = [Edge('a', 'b'), Edge('a', 'c'), Edge('b', 'c')])\n\n    assert len(solution(g)) == 3\n\n    g = Graph(nodes = ['1', '2', '3', '4'], \n              edges = [Edge('1', '2'), Edge('1', '3'), Edge('1', '4'), Edge('4', '3')])\n\n    assert len(solution(g)) == 3\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass, field\nfrom collections import namedtuple\n\n\nEdge = namedtuple('Edge', ['start', 'end'])\ntype SpanningTree = set[Edge]\n\n@dataclass\nclass Graph[T]:\n    nodes: list[T]\n    edges: list[Edge]\n\nMerges = namedtuple('Merges', ['index_start', 'index_end', 'popped_values'])\n\n@dataclass\nclass EdgeSet[T]:\n    edges: list[Edge] = field(default_factory=list)\n    connected_nodes: list[set[T]] = field(default_factory=list)\n    history: list[Merges] = field(default_factory=list)\n\n    def find_node(self, node: T) -&gt; int:\n        return next((idx \n                    for idx, nodes in enumerate(self.connected_nodes) \n                    if node in nodes))\n\n    def creates_loop(self, edge: Edge) -&gt; bool:\n        # If both nodes are in the same connected set of nodes, that would create a loop\n        return self.find_node(edge.start) == self.find_node(edge.end)\n\n    def add_edge(self, edge: Edge) -&gt; None:\n        self.edges.append(edge)\n\n        idx_start = self.find_node(edge.start)\n        idx_end = self.find_node(edge.end)\n\n        self.connected_nodes[idx_start] |= self.connected_nodes[idx_end]\n        self.history.append(Merges(idx_start, idx_end, self.connected_nodes[idx_end]))    \n        self.connected_nodes[idx_end] = set()\n\n\n    def undo_action(self) -&gt; None:\n        self.edges.pop()\n        idx_start, idx_end, popped = self.history.pop()\n        self.connected_nodes[idx_start].difference_update(popped)\n        self.connected_nodes[idx_end] = set(popped)\n\n\ndef generate_spanning_trees_v1(graph: Graph) -&gt; list[SpanningTree]:\n    valid_choices = []\n    required_edges = len(graph.nodes) - 1\n\n    def aux(accumulated_edges: EdgeSet, possible_edges: list[Edge]):\n        if len(accumulated_edges.edges) == required_edges:\n            valid_choices.append(tuple(accumulated_edges.edges))\n            return\n\n        if not possible_edges or len(accumulated_edges.edges) + len(possible_edges) &lt; required_edges:\n            return\n\n        head, *tail = possible_edges\n        creates_loop = accumulated_edges.creates_loop(head)\n\n        if not creates_loop:\n            accumulated_edges.add_edge(head)\n            aux(accumulated_edges, tail)\n            accumulated_edges.undo_action()\n\n        aux(accumulated_edges, tail)\n\n\n    aux(EdgeSet([], [{node} for node in graph.nodes], []), graph.edges)\n    return valid_choices\n</code></pre>","tags":["Tree","Intermediate"]},{"location":"problems/p55_find_minimal_spanning_tree/","title":"Find the Minimal Spanning Tree","text":"<p>Find the minimal spanning tree for a weighted/labelled graph.</p> TestPrim <pre><code>def test_final_minimal_spanning_tree(solution):\n    g = Graph(nodes = ['a', 'b', 'c'],\n              edges = [Edge('a', 'b', 2), Edge('a', 'c', 1), Edge('b', 'c', 1)])\n\n    assert solution(g)[1] == 2\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\nfrom sortedcontainers import SortedList\nfrom collections import defaultdict\n\n@dataclass(frozen=True)\nclass Edge[T]:\n    start: T\n    end: T\n    value: int\n\n@dataclass\nclass Graph[T]:\n    nodes: list[T]\n    edges: list[Edge]\n\ntype SpanningTree = set[Edge]\ntype Cost = int    \n\n\ndef find_minimal_spanning_tree_v1(graph: Graph) -&gt; tuple[SpanningTree, Cost]:\n    def get_adjacency_form[T](graph: Graph) -&gt; defaultdict[T, set[Edge]]:\n        lookup = defaultdict(set)\n        for edge in graph.edges:\n            lookup[edge.start].add(edge)\n            lookup[edge.end].add(Edge(edge.end, edge.start, edge.value))\n\n        return lookup\n\n    def get_next_valid_edge(pq: SortedList, seen_nodes: set) -&gt; iter[Edge]:\n        while pq and (cheapest_edge := pq.pop(0)):\n            if cheapest_edge.end not in seen_nodes:\n                yield cheapest_edge\n\n    lookup = get_adjacency_form(graph)\n    edges_to_consider = SortedList([], key=lambda elem: elem.value)\n    working_tree = set()\n    seen_nodes = set()\n    cost = 0\n    required_size = len(graph.nodes) - 1\n\n    seen_nodes.add(graph.nodes[0])\n    edges_to_consider.update(lookup[graph.nodes[0]])\n\n    for edge in get_next_valid_edge(edges_to_consider, seen_nodes):\n        if len(working_tree) == required_size:\n            break\n\n        working_tree.add(edge)\n        seen_nodes.add(edge.end)\n        cost += edge.value\n        edges_to_consider.update(lookup[edge.end])\n\n    return working_tree, cost\n</code></pre>","tags":["Graph","Intermediate"]},{"location":"problems/p56_graph_isomorphism/","title":"Graph Isomorphism","text":"<p>Find the function \\(F\\) if it exists that makes two graphs \\(G_i\\) and \\(G_j\\;\\) isomorphic.</p> <p>We have two graphs \\(G_i\\) and \\(G_j\\;\\). </p> <p>A function \\(F\\) defines a mapping between a node \\(N_0 \u2208 G_i \\;\\) and a node \\(M_0 \u2208 G_j \\;\\) so this means \\(F(N_0) \u2192 M_0\\). </p> <p>In other words, \\(F\\) can be thought of as a dictionary where the keys are nodes from \\(G_i\\) and the values are nodes from \\(G_j\\).</p> <p>\\(F\\) is not allowed to map 2 nodes from \\(G_i\\) to the same node in \\(G_j \\;\\) so \\(F(N_0) \u2260 F(N_1)\\)</p> <p>\\(F\\) must map all nodes from \\(G_i\\) to all nodes from \\(G_j \\;\\) so this means the number of nodes in \\(G_i\\) must equal the number of nodes in \\(G_j\\). </p> <p>\\(Adj(N_0) \u2192 A_0 \\;\\) is the set of nodes adjacent to \\(N_0\\)</p> <p>\\(Adj(M_0) \u2192 B_0 \\;\\) is the set of nodes adjacent to \\(M_0\\)</p> <p>If \\(\\; F(Adj(N_0)) = Adj(F(N_0))\\) for all nodes \\(N_0 \\;\\) from \\(G_i\\;\\) then \\(G_i\\;\\) and \\(G_j\\;\\) are isomorphic. This means that the structure of \\(G_i\\) and \\(G_j\\;\\) is identical under the mapping \\(F\\).</p> TestRecursive <pre><code># Graph 1: A simple square with number nodes\nnodes1 = {Node(i) for i in range(1, 5)}\nedges1 = {\n    Edge(Node(1), Node(2)), Edge(Node(2), Node(3)),\n    Edge(Node(3), Node(4)), Edge(Node(4), Node(1))\n}\ng1 = Graph(nodes1, edges1)\n\n# Graph 2: A simple square with letter nodes\nnodes2 = {Node(c) for c in \"ABCD\"}\nedges2 = {\n    Edge(Node('A'), Node('B')), Edge(Node('B'), Node('C')),\n    Edge(Node('C'), Node('D')), Edge(Node('D'), Node('A'))\n}\ng2 = Graph(nodes2, edges2)\n\n# Graph 3: A \"kite\" graph\nnodes3 = {Node(i) for i in range(1, 5)}\nedges3 = {\n    Edge(Node(1), Node(2)), Edge(Node(2), Node(3)),\n    Edge(Node(3), Node(4)), Edge(Node(4), Node(1)),\n    Edge(Node(1), Node(3))\n}\ng3 = Graph(nodes3, edges3)\n\ndef test_isomorphic_graphs(solution):\n    mappings = solution(g1, g2)\n\n    assert len(mappings) == 8\n\n    expected_mapping = {\n        Node(1): Node('A'),\n        Node(2): Node('B'),\n        Node(3): Node('C'),\n        Node(4): Node('D')\n    }\n    assert expected_mapping in mappings\n\ndef test_non_isomorphic_graphs(solution):\n    mappings = solution(g1, g3)\n    assert mappings == []\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass, field\nfrom bidict import bidict\nfrom collections import namedtuple, defaultdict\n\nNode = namedtuple('Node', ['name'])\n\n@dataclass(frozen=True)\nclass Edge:\n    start: Node\n    end: Node\n\n    def flip(self) -&gt; Edge:\n        return Edge(self.end, self.start)\n\n@dataclass\nclass Graph:\n    nodes: set[Node] = field(default_factory=set)\n    edges: set[Edge] = field(default_factory=set)\n\n    def add(self, node: Node, edges: iter[Edge]):\n        self.nodes.add(node)\n        self.edges.update(edges)\n\n    def remove(self, node: Node, edges: iter[Edge]):\n        self.nodes.difference_update((node,))\n        self.edges.difference_update(edges)\n\n\ntype Mapping = bidict[Node, Node]\ntype AdjacencyGraph = defaultdict[Node, set[Edge]]\n\ndef find_isomorph_v1(gi: Graph, gj: Graph) -&gt; Mapping:\n\n    def get_adjacency_form(graph: Graph) -&gt; AdjacencyGraph:\n        lookup = defaultdict(set)\n        for edge in graph.edges:\n            lookup[edge.start].add(edge)\n            lookup[edge.end].add(edge.flip())\n\n        return lookup\n\n    def find_edges_that_terminate_within_graph(node: Node, mapped_nodes: set[Node], lookup_g: AdjacencyGraph) -&gt; set[Edge]:\n        return {terminating_edge \n                for terminating_edge in lookup_g[node] \n                if terminating_edge.end in mapped_nodes}\n\n    def is_possible_candidate(n_0: Node, n_0_edges: set[Edge], working_f: Mapping, m_0: Node) -&gt; bool:\n        is_mapped = m_0 in working_f.inverse.keys()\n        if is_mapped:\n            return False\n\n        degree_matches = len(lookup_gi[n_0]) == len(lookup_gj[m_0])\n        if not degree_matches:\n            return False\n\n        m_0_edges = find_edges_that_terminate_within_graph(m_0, working_f.inverse.keys(), lookup_gj)\n        size_matches = len(n_0_edges) == len(m_0_edges)\n        if not size_matches:\n            return False\n\n        edges_match = {working_f[edge.end] for edge in n_0_edges} == {edge.end for edge in m_0_edges}\n        if not edges_match:\n            return False\n\n        return True\n\n    def aux(working_f: Mapping):\n        if len(working_f) == len(gi.nodes):\n            valid_mappings.append(working_f.copy())\n            return\n\n        n_0 = next((node for node in gi.nodes \n                    if node not in working_f))\n        respective_n_0_edges = find_edges_that_terminate_within_graph(n_0, working_f.keys(), lookup_gi)\n\n        candidates = (m_0 for m_0 in gj.nodes\n                      if is_possible_candidate(n_0, respective_n_0_edges, working_f, m_0))\n\n        for m_0 in candidates:\n            working_f[n_0] = m_0\n            aux(working_f)\n            working_f.pop(n_0)\n\n\n    valid_mappings = []\n    if len(gi.nodes) != len(gj.nodes): return valid_mappings\n\n    lookup_gi = get_adjacency_form(gi)\n    lookup_gj = get_adjacency_form(gj)\n\n    aux(bidict())\n\n    return valid_mappings\n</code></pre>","tags":["Graph","Intermediate"]},{"location":"problems/p57_graph_coloring/","title":"Graph Coloring","text":"<p>Given a graph \\(G\\), find the minimum number of colors needed such that each node can be painted a color and any of its adjacent nodes are a different color. In other words, no adjacent nodes can be  the same color. How many colors would we need?</p> TestRecursive <pre><code># Graph 1: A triangle\nn_a, n_b, n_c = Node('A'), Node('B'), Node('C')\ng_triangle = Graph(\n    nodes={n_a, n_b, n_c},\n    edges={Edge(n_a, n_b), Edge(n_b, n_c), Edge(n_c, n_a)}\n)\n\n# Graph 2: A square\nn_d = Node('D')\ng_square = Graph(\n    nodes={n_a, n_b, n_c, n_d},\n    edges={Edge(n_a, n_b), Edge(n_b, n_c), Edge(n_c, n_d), Edge(n_d, n_a)}\n)\n\n# Graph 3: A line graph\ng_line = Graph(\n    nodes={n_a, n_b, n_c, n_d},\n    edges={Edge(n_a, n_b), Edge(n_b, n_c), Edge(n_c, n_d)}\n)\n\n# Graph 4: A disconnected graph\nn_e, n_f = Node('E'), Node('F')\ng_disconnected = Graph(\n    nodes={n_a, n_b, n_c, n_d, n_e, n_f},\n    edges={\n        # Component 1: A triangle (requires 3 colors)\n        Edge(n_a, n_b), Edge(n_b, n_c), Edge(n_c, n_a),\n        # Component 2: A single edge (requires 2 colors)\n        Edge(n_d, n_e)\n    }\n)\n\n# Graph 5: A graph with nodes but no edges\ng_no_edges = Graph(\n    nodes={n_a, n_b, n_c}\n)\n\ntest_cases = [\n    pytest.param(g_triangle, 3, id=\"3-colorable triangle\"),\n    pytest.param(g_square, 2, id=\"2-colorable square\"),\n    pytest.param(g_line, 2, id=\"2-colorable line\"),\n    pytest.param(g_disconnected, 3, id=\"disconnected\"),\n    pytest.param(g_no_edges, 1, id=\"1-colorable (no edges)\"),\n    pytest.param(Graph(), 0, id=\"empty graph\"),\n]\n\n@pytest.mark.parametrize(\"graph, expected_num_colors\", test_cases)\n@pytest.mark.parametrize(\"solution\", implementations, ids=ids)\ndef test_color_graph(solution, graph, expected_num_colors):\n    coloring = solution(graph)\n    colors_used = set(coloring.values())\n    assert len(colors_used) == expected_num_colors\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass, field\nfrom collections import namedtuple\n\nNode = namedtuple('Node', ['name'])\n\n@dataclass(frozen=True)\nclass Edge:\n    start: Node\n    end: Node\n\n    def flip(self) -&gt; Edge:\n        return Edge(self.end, self.start)\n\n@dataclass\nclass Graph:\n    nodes: set[Node] = field(default_factory=set)\n    edges: set[Edge] = field(default_factory=set)\n\ntype Color = int\ntype ColorMapping = dict[Node, Color]\ntype Palette = set[Color]\ntype AdjacencyGraph = dict[Node, set[Edge]]\n\ndef color_graph_v1(graph: Graph) -&gt; ColorMapping:\n    def get_adjacency_form(graph: Graph) -&gt; AdjacencyGraph:\n        lookup = {n: set() for n in graph.nodes}\n        for edge in graph.edges:\n            lookup[edge.start].add(edge)\n            lookup[edge.end].add(edge.flip())\n\n        # Hueristic (Welsh-Powell) - color node with highest degree\n        nodes_sorted_by_degree = dict(sorted(lookup.items(), key=lambda item: len(item[1]), reverse=True))\n        return nodes_sorted_by_degree\n\n    def get_larger_palette(p: Palette) -&gt; Palette:\n        return set(range(0, len(p) + 1))\n\n    def color_graph_with_palette(color_f: ColorMapping, p: Palette, adjacency_g: AdjacencyGraph) -&gt; ColorMapping | None:\n        if len(color_f) == len(graph.nodes):\n            return color_f\n\n        uncolored_node = next((node for node in adjacency_g.keys() if node not in color_f), None)\n        neighbor_colors = {color_f.get(edge.end, None) for edge in adjacency_g[uncolored_node]}\n        possible_colors = p - neighbor_colors\n\n        for color in possible_colors:\n            color_f[uncolored_node] = color\n            if color_graph_with_palette(color_f, p, adjacency_g) is not None:\n                return color_f\n            color_f.pop(uncolored_node)\n\n        return None\n\n    if len(graph.nodes) == 0: \n        return {}\n\n    curr_palette = {0}\n    lookup_g = get_adjacency_form(graph)\n\n    while (mapping := color_graph_with_palette({}, curr_palette, lookup_g)) is None:\n        curr_palette = get_larger_palette(curr_palette)\n\n    return mapping\n</code></pre>","tags":["Graph","Intermediate"]},{"location":"problems/p58_connected_components/","title":"Connected Components","text":"<p>Given a graph \\(G\\), find all the connected components of \\(G\\). A connected component is a subgraph where nodes of the subgraph have a path to each other. It is possible for a connect component to be exactly \\(G\\), this would happen when every node has a path to every other node.</p> TestRecursiveMutual Recursion <pre><code># Graph 1: A empty graph\ng1 = Graph(set(), set())\n\n# Graph 2: A single node\ng2 = Graph(nodes={Node('a')}, edges=set())\n\n# Graph 3: All connected nodes\ng3 = Graph({Node('a'), Node('b'), Node('c'), Node('d')}, \n           {Edge(Node('a'), Node('b')), \n            Edge(Node('b'), Node('c')), Edge(Node('a'), Node('d'))})\n\n# Graph 4: Several components\ng4 = Graph({Node('a'), Node('b'), Node('c'), Node('d'), \n            Node('e'), Node('f'), Node('g')}, \n           {Edge(Node('a'), Node('b')),\n            Edge(Node('c'), Node('d')), Edge(Node('d'), Node('e'))})\n\ntest_cases = [\n    pytest.param(g1, 0, id=\"empty\"),\n    pytest.param(g2, 1, id=\"single\"),\n    pytest.param(g3, 1, id=\"fully connected\"),\n    pytest.param(g4, 4, id=\"several groups\"),\n]\n\n@pytest.mark.parametrize(\"graph, expected_num_components\", test_cases)\n@pytest.mark.parametrize(\"solution\", implementations, ids=ids)\ndef test_connected_components(solution, graph, expected_num_components):\n    components = solution(graph)\n    assert len(components) == expected_num_components\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\nfrom collections import namedtuple\n\nNode = namedtuple('Node', ['name'])\n\n@dataclass(frozen=True)\nclass Edge:\n    start: Node\n    end: Node\n\n    def flip(self) -&gt; Edge:\n        return Edge(self.end, self.start)\n\n@dataclass(frozen=True)\nclass Graph:\n    nodes: set[Node]\n    edges: set[Edge]\n\n\ntype Component = set[Node]\ntype AdjacencyGraph = dict[Node, set[Edge]]\n\ndef get_adjacency_form(graph: Graph) -&gt; AdjacencyGraph:\n    lookup = {node: set() for node in graph.nodes}\n    for edge in graph.edges:\n        lookup[edge.start].add(edge)\n        lookup[edge.end].add(edge.flip())\n\n    return lookup\n\n\ndef find_connected_components_v1(graph: Graph) -&gt; list[Component]:\n    def dfs(curr_node: Node, working_component: Component, adjacency_graph: AdjacencyGraph) -&gt; Component:\n        working_component.add(curr_node)\n\n        neighbors = (edge.end \n                     for edge in adjacency_graph[curr_node] \n                     if edge.end not in working_component)\n\n        for next_node in neighbors:\n            dfs(next_node, working_component, adjacency_graph)\n\n        return working_component\n\n    connected_components = []\n    remaining_nodes = graph.nodes.copy()\n    lookup_g = get_adjacency_form(graph)\n\n    while len(remaining_nodes) &gt; 0:\n        seed_node = next(iter(remaining_nodes))\n        component = dfs(seed_node, set(), lookup_g)\n        remaining_nodes -= component\n        connected_components.append(component)\n\n    return connected_components\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\nfrom collections import namedtuple\n\nNode = namedtuple('Node', ['name'])\n\n@dataclass(frozen=True)\nclass Edge:\n    start: Node\n    end: Node\n\n    def flip(self) -&gt; Edge:\n        return Edge(self.end, self.start)\n\n@dataclass(frozen=True)\nclass Graph:\n    nodes: set[Node]\n    edges: set[Edge]\n\n\ntype Component = set[Node]\ntype AdjacencyGraph = dict[Node, set[Edge]]\n\ndef get_adjacency_form(graph: Graph) -&gt; AdjacencyGraph:\n    lookup = {node: set() for node in graph.nodes}\n    for edge in graph.edges:\n        lookup[edge.start].add(edge)\n        lookup[edge.end].add(edge.flip())\n\n    return lookup\n\n\ndef find_connected_components_v2(graph: Graph) -&gt; list[Component]:\n    def dfs(curr_node: Node, working_component: set[Node]) -&gt; Component:\n        working_component.add(curr_node)\n\n        neighbors = (edge.end for edge in lookup_g[curr_node] \n                     if edge.end not in working_component)\n\n        for next_node in neighbors:\n            dfs(next_node, working_component)\n\n        return working_component\n\n    def find_components(visited: set[Node]) -&gt; list[Component]:\n        unseen_node = next(iter(graph.nodes - visited), None)\n        if unseen_node is None: \n            return []\n\n        component = dfs(unseen_node, set())\n        return [component] + find_components(visited | component)\n\n    lookup_g = get_adjacency_form(graph)\n    return find_components(set())\n</code></pre>","tags":["Graph","Intermediate"]},{"location":"problems/p59_is_bipartite/","title":"Is Bipartite","text":"<p>Check if a graph \\(G\\) is bipartite (is it 2 colorable).</p> TestRecursive <pre><code>N = Node\n\n# Graph 1: A triangle (3-node odd cycle)\nn_a, n_b, n_c = N('A'), N('B'), N('C')\ng_triangle = Graph(\n    nodes={n_a, n_b, n_c},\n    edges={Edge(n_a, n_b), Edge(n_b, n_c), Edge(n_c, n_a)}\n)\n\n# Graph 2: A square (4-node even cycle)\nn_d = N('D')\ng_square = Graph(\n    nodes={n_a, n_b, n_c, n_d},\n    edges={Edge(n_a, n_b), Edge(n_b, n_c), Edge(n_c, n_d), Edge(n_d, n_a)}\n)\n\n# Graph 3: A line graph\ng_line = Graph(\n    nodes={n_a, n_b, n_c, n_d},\n    edges={Edge(n_a, n_b), Edge(n_b, n_c), Edge(n_c, n_d)}\n)\n\n# Graph 4: A disconnected graph where all components are bipartite\nn_e, n_f, n_g, n_h = N('E'), N('F'), N('G'), N('H')\ng_disconnected_bipartite = Graph(\n    nodes={n_a, n_b, n_c, n_d, n_e, n_f, n_g, n_h},\n    edges={\n        Edge(n_a, n_b), Edge(n_b, n_c),\n        Edge(n_e, n_f),\n    }\n)\n\n# Graph 5: A disconnected graph with a non-bipartite component\ng_disconnected_non_bipartite = Graph(\n    nodes={n_a, n_b, n_c, n_d, n_e},\n    edges={\n        Edge(n_a, n_b), Edge(n_b, n_c), Edge(n_c, n_a),\n        Edge(n_d, n_e)\n    }\n)\n\n# Graph 6: A \"star\" graph\ng_star = Graph(\n    nodes={n_a, n_b, n_c, n_d},\n    edges={Edge(n_a, n_b), Edge(n_a, n_c), Edge(n_a, n_d)}\n)\n\ntest_cases = [\n    pytest.param(g_triangle, False, id=\"non-bipartite (triangle)\"),\n    pytest.param(g_square, True, id=\"bipartite (square)\"),\n    pytest.param(g_line, True, id=\"bipartite (line)\"),\n    pytest.param(g_star, True, id=\"bipartite (star graph)\"),\n    pytest.param(g_disconnected_bipartite, True, id=\"bipartite (disconnected)\"),\n    pytest.param(g_disconnected_non_bipartite, False, id=\"non-bipartite (disconnected)\"),\n    pytest.param(Graph(set(), set()), True, id=\"bipartite (empty graph)\"),\n]\n\n\n@pytest.mark.parametrize(\"graph, expected_result\", test_cases)\n@pytest.mark.parametrize(\"solution\", implementations, ids=ids)\ndef test_is_bipartite(solution, graph, expected_result):\n    assert solution(graph) == expected_result\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\nfrom collections import namedtuple\n\ntype AdjacencyGraph = dict[Node, set[Edge]]\ntype Color = int\ntype Palette = set[Color]\ntype ColorMapping = dict[Node, Color]\n\nNode = namedtuple('Node', ['name'])\n\n@dataclass(frozen=True)\nclass Edge:\n    start: Node\n    end: Node\n\n    def flip(self) -&gt; Edge:\n        return Edge(self.end, self.start)\n\n@dataclass\nclass Graph:\n    nodes: set[Node]\n    edges: set[Edge]\n\n    def get_adacencey_form(self) -&gt; AdjacencyGraph:\n        lookup = {node: set() for node in self.nodes}\n        for edge in self.edges:\n            lookup[edge.start].add(edge)\n            lookup[edge.end].add(edge.flip())\n\n        return lookup\n\n\ndef is_bipartite_v1(graph: Graph) -&gt; bool:\n    def dfs(curr_node: Node, color_f: ColorMapping) -&gt; ColorMapping | None:\n        neighbors = (edge.end for edge in lookup_g[curr_node])\n        curr_node_color = color_f[curr_node]\n\n        for neighbor_node in neighbors:\n            match color_f.get(neighbor_node, None):\n                case None:\n                    color_f[neighbor_node] = (curr_node_color + 1) % 2\n                    if dfs(neighbor_node, color_f) is None: \n                        return None\n\n                case neighbor_color if curr_node_color == neighbor_color:\n                    return None\n\n        return color_f\n\n\n    def jump_and_color(color_f: ColorMapping) -&gt; ColorMapping | None:\n        unseen_node = next(iter(graph.nodes - color_f.keys()), None)\n        if unseen_node is None:\n            return color_f\n\n        color_f[unseen_node] = 0\n        if dfs(unseen_node, color_f) is None:\n            return None\n\n        return jump_and_color(color_f)\n\n    lookup_g = graph.get_adacencey_form()\n    coloring = jump_and_color({})\n    return coloring is not None\n</code></pre>","tags":["Graph","Intermediate"]},{"location":"problems/p60_find_non_isomorphic_k_regular_graphs/","title":"Find Non-Isomorphic K-Regular Graphs with N nodes","text":"<p>Find all non-isomorphic graphs that are K regular and have N nodes. </p> <pre><code>---\ntitle: 3-Regular Graph with 6 Nodes\n---\n\ngraph TD\n    A(a) &lt;--&gt; B(b)\n    A(a) &lt;--&gt; C(c)\n    A(a) &lt;--&gt; D(d)\n\n    B(b) &lt;--&gt; C(c)\n    B(b) &lt;--&gt; E(e)\n\n    C(c) &lt;--&gt; F(f)\n\n    D(d) &lt;--&gt; F(f)\n    D(d) &lt;--&gt; E(e)\n\n    E(e) &lt;--&gt; F(f)\n\n    %% Color Definitions\n    classDef color1 fill:#ffadad,stroke:#333,stroke-width:2px,color:black\n    classDef color2 fill:#a0cbe8,stroke:#333,stroke-width:2px,color:black\n    classDef color3 fill:#90ee90,stroke:#333,stroke-width:2px,color:black\n\n    %% Color Assignments\n    class A,E color1\n    class B,F color2\n    class C,D color3</code></pre> <pre><code>---\ntitle: 3-Regular Graph with 6 Nodes\n---\n\ngraph TD\n    A(a) &lt;--&gt; B(b)\n    A(a) &lt;--&gt; C(c)\n    A(a) &lt;--&gt; D(d)\n\n    B(b) &lt;--&gt; E(e)\n    B(b) &lt;--&gt; F(f)\n\n    C(c) &lt;--&gt; F(f)\n    C(c) &lt;--&gt; E(e)\n\n    D(d) &lt;--&gt; F(f)\n    D(d) &lt;--&gt; E(e)\n\n    %% Color Definitions\n    classDef color1 fill:#ffadad,stroke:#333,stroke-width:2px,color:black\n    classDef color2 fill:#a0cbe8,stroke:#333,stroke-width:2px,color:black\n\n    %% Color Assignments\n    class A,E,F color1\n    class B,C,D color2</code></pre> TestCanonical LabelMismatch Hueristic <pre><code>def graph_from_str(g_str, num_nodes) -&gt; Graph:\n    nodes = [Node(str(i)) for i in range(1, num_nodes + 1)]\n    edge_set = set()\n    for pair in g_str.split(', '):\n        start, end = pair.split('-')\n        start_node = nodes[int(start) - 1]\n        end_node = nodes[int(end) - 1]\n        edge_set.add(Edge(start_node, end_node))\n\n    return Graph(nodes, edge_set)\n\n# From https://www.ic.unicamp.br/~meidanis/courses/mc336/2009s2/prolog/problemas/p94.txt\nr2n3_str = \"1-2, 1-3, 2-3\"\nr2n3 = graph_from_str(r2n3_str, 3)\n\nr3n6_str = \"1-2, 1-3, 1-4, 2-3, 2-5, 3-6, 4-5, 4-6, 5-6\"\nr3n6 = graph_from_str(r3n6_str, 6)\n\nr5n8_str = \"1-2, 1-3, 1-4, 1-5, 1-6, 2-3, 2-4, 2-5, 2-6, 3-4, 3-7, 3-8, 4-7, 4-8, 5-6, 5-7, 5-8, 6-7, 6-8, 7-8\"\nr5n8 = graph_from_str(r5n8_str, 8)\n\n\ntest_cases = [\n    pytest.param(r2n3, 1, id=\"2 Regular 3 Node\"),\n    pytest.param(r3n6, 2, id=\"3 Regular 6 Node\"),\n    pytest.param(r5n8, 3, id=\"5 Regular 8 Node\"),\n]\n\n@pytest.mark.parametrize(\"graph, expected_result\", test_cases)\n@pytest.mark.parametrize(\"solution\", implementations, ids=ids)\ndef test_find_non_isomorphic_k_regular_graphs(solution, graph, expected_result):\n    assert len(solution(graph)) == expected_result\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\nimport numpy as np\nfrom numpy import typing as npt\nfrom itertools import combinations, permutations\nfrom collections import deque\nfrom math import isqrt\n\n@dataclass(frozen=True)\nclass Node:\n    name: str\n\n@dataclass(frozen=True)\nclass Edge:\n    start: Node\n    end: Node\n\n@dataclass\nclass Graph:\n    nodes: set[Node]\n    edges: set[Edge]\n\n    def get_adjacency_matrix(self) -&gt; tuple[npt.NDArray[np.bool], list[str]]:\n        sorted_nodes = sorted(list(self.nodes), key=lambda n: n.name)\n        enumeration = {node: enum for enum, node in enumerate(sorted_nodes)}\n\n        m = np.zeros((len(self.nodes), len(self.nodes)), dtype=bool)\n\n        for edge in self.edges:\n            start_idx = enumeration[edge.start]\n            end_idx = enumeration[edge.end]\n            m[start_idx][end_idx] = True\n            m[end_idx][start_idx] = True\n\n        return m\n\ntype BitVector = npt.NDArray[np.bool]\ntype BitString = str\n\ndef find_non_isomorophic_graphs_v1(graph: Graph) -&gt; set[BitString]:\n    def to_bin_str(vec) -&gt; str:\n        return \"\".join(vec.astype(int).astype(str))\n\n    def gen_next_graph(current_graph: BitVector, seen_graphs: set[BitString]) -&gt; iter[BitVector]:\n        num_of_nodes = isqrt(len(current_graph))\n        zero_locs = np.where(current_graph == 0)[0]\n        row_idx = zero_locs // num_of_nodes\n        col_idx = zero_locs % num_of_nodes\n        upper_tri_zero_coords = np.column_stack([row_idx[np.where(col_idx &gt; row_idx)[0]], \n                                                 col_idx[np.where(col_idx &gt; row_idx)[0]],])\n\n        zero_pairings = combinations(upper_tri_zero_coords, 2)\n\n        def map_coord(coord: tuple[int, int]) -&gt; int:\n            return coord[0] * num_of_nodes + coord[1]\n\n        def invert_coord(coord: tuple[int, int]) -&gt; tuple[int, int]:\n            return coord[1], coord[0]\n\n        def construct_edge_switched_graph(hole_coord_1, hole_coord_2, edge_coord_1, edge_coord_2) -&gt; BitVector:\n            # Picking a rectangle in the matrix with zeros on its diagonal and ones on its other diagonal (4 points)\n            # Reflecting it across the diagonal (4 points)\n            # Setting those 8 points in total\n\n            coords_flipping_to_1 = [hole_coord_1, hole_coord_2, \n                                    invert_coord(hole_coord_1), invert_coord(hole_coord_2)]\n            coords_flipping_to_0 = [edge_coord_1, edge_coord_2, \n                                    invert_coord(edge_coord_1), invert_coord(edge_coord_2)]\n\n            new_graph = current_graph.copy()\n            new_graph[[map_coord(c) for c in coords_flipping_to_1]] = True\n            new_graph[[map_coord(c) for c in coords_flipping_to_0]] = False\n            return new_graph\n\n        for zero_coord_1, zero_coord_2 in zero_pairings:\n            a, b = zero_coord_1\n            c, d = zero_coord_2\n\n            # First possible mapping\n            has_edge_1 = current_graph[map_coord((a, c))]\n            has_edge_2 = current_graph[map_coord((b, d))]\n\n            if not (has_edge_1 and has_edge_2):\n                continue\n\n            p1 = construct_edge_switched_graph(zero_coord_1, zero_coord_2, (a, c), (b, d))\n\n            if (p1_bin_str := to_bin_str(p1)) not in seen_graphs:\n                seen_graphs.add(p1_bin_str)\n                yield p1\n\n            # Second possible mapping\n            has_edge_1 = current_graph[map_coord((a, d))]\n            has_edge_2 = current_graph[map_coord((b, c))]\n\n            if not (has_edge_1 and has_edge_2):\n                continue\n\n            p2 = construct_edge_switched_graph(zero_coord_1, zero_coord_2, (a, d), (b, c))\n\n            if (p2_bin_str := to_bin_str(p2)) not in seen_graphs:\n                seen_graphs.add(p2_bin_str)\n                yield p2\n\n    def generate_all_graphs(given_graph: Graph) -&gt; set[BitString]:\n        lookup = given_graph.get_adjacency_matrix()\n        lookup_bin_str = \"\".join(lookup.flatten().astype(int).astype(str))\n        seen_graphs = {lookup_bin_str}\n        nodes = deque([lookup.flatten()])\n\n        while nodes:\n            current_graph = nodes.popleft()\n            for generated_graph in gen_next_graph(current_graph, seen_graphs):\n                nodes.append(generated_graph)\n\n        return seen_graphs\n\n    def find_canonical_form(graph: BitString) -&gt; BitString:\n        num_of_nodes = isqrt(len(graph))\n        perms = permutations(range(num_of_nodes))\n        adj_matrix = np.array(tuple(graph), dtype=int).reshape(num_of_nodes, num_of_nodes)\n        max_bit_vector = adj_matrix.flatten()\n\n        for p in perms:\n            permutated_matrix = adj_matrix[p, :][:, p]\n            p_matrix_flat = permutated_matrix.flatten()\n            diff_indices = np.where(p_matrix_flat != max_bit_vector)[0]\n\n            if diff_indices.size != 0:\n                first_diff_indx = diff_indices[0]\n                if max_bit_vector[first_diff_indx] &lt; p_matrix_flat[first_diff_indx]:\n                    max_bit_vector = p_matrix_flat\n\n        return to_bin_str(max_bit_vector)\n\n    return {find_canonical_form(g) for g in generate_all_graphs(graph)}\n</code></pre> <pre><code>from __future__ import annotations\nfrom dataclasses import dataclass\nimport numpy as np\nfrom numpy import typing as npt\nfrom itertools import combinations, permutations\nfrom collections import deque\nfrom math import isqrt\n\n@dataclass(frozen=True)\nclass Node:\n    name: str\n\n@dataclass(frozen=True)\nclass Edge:\n    start: Node\n    end: Node\n\n@dataclass\nclass Graph:\n    nodes: set[Node]\n    edges: set[Edge]\n\n    def get_adjacency_matrix(self) -&gt; tuple[npt.NDArray[np.bool], list[str]]:\n        sorted_nodes = sorted(list(self.nodes), key=lambda n: n.name)\n        enumeration = {node: enum for enum, node in enumerate(sorted_nodes)}\n\n        m = np.zeros((len(self.nodes), len(self.nodes)), dtype=bool)\n\n        for edge in self.edges:\n            start_idx = enumeration[edge.start]\n            end_idx = enumeration[edge.end]\n            m[start_idx][end_idx] = True\n            m[end_idx][start_idx] = True\n\n        return m\n\ntype BitVector = npt.NDArray[np.bool]\ntype BitString = str\ntype PermSwap = tuple\n\ndef find_non_isomorphic_graphs_v2(graph: Graph) -&gt; set[BitString]:\n    def to_bin_str(vec) -&gt; str:\n        return \"\".join(vec.astype(int).astype(str))\n\n    def to_bit_vector(bitstr: BitString) -&gt; BitVector:\n        nodes = isqrt(len(bitstr))\n        adj_matrix = np.array(tuple(bitstr), dtype=int).reshape(nodes, nodes)\n        return adj_matrix.flatten()\n\n    def compose_perm_swap(init_state: tuple, idxs_to_swap: tuple[int, int]) -&gt; tuple:\n        i, j = idxs_to_swap\n        copied = list(init_state)\n        copied[i], copied[j] = init_state[j], init_state[i]\n        return tuple(copied)\n\n    def hole_edge_matches(all_edge_missing_coord, all_hole_missing_coords) -&gt; iter[tuple[int, int]]:\n        for missing_edge_coord in all_edge_missing_coord:\n            row, col = missing_edge_coord\n            horizontal_matches = all_hole_missing_coords[all_hole_missing_coords[:, 0] == row]\n            vertical_matches = all_hole_missing_coords[all_hole_missing_coords[:, 1] == col]\n\n            yield from ((int(col), int(e[1])) for e in horizontal_matches)\n            yield from ((int(e[0]), int(row)) for e in vertical_matches)\n\n    def is_isomorphic(og_graph: BitVector, eg_graph: BitVector) -&gt; bool:\n        num_of_nodes = isqrt(len(og_graph))\n\n        og_mat = og_graph.reshape(num_of_nodes, num_of_nodes)\n        eg_mat = eg_graph.reshape(num_of_nodes, num_of_nodes)\n\n        nodes = deque([(tuple(range(num_of_nodes)), 0)])\n        seen_diffs = set()\n        seen_perms = set()\n\n        while nodes:\n            curr_prem, num_of_swaps = nodes.popleft()\n\n            perm_applied_mat = og_mat[curr_prem, :][:, curr_prem]\n            diff_mat = eg_mat - perm_applied_mat\n\n            if (diff_mat_bin_str := to_bin_str(diff_mat.flatten())) in seen_diffs:\n                continue\n\n            seen_diffs.add(diff_mat_bin_str)\n\n            edge_missing_coords = np.column_stack(np.where(diff_mat == -1))\n            hole_missing_coords = np.column_stack(np.where(diff_mat == 1))\n\n            if len(edge_missing_coords) == 0 and len(hole_missing_coords) == 0:\n                return True\n\n            upper_tri_edge_missing_coords = edge_missing_coords[edge_missing_coords[:, 1] &gt; edge_missing_coords[:, 0]]\n            upper_tri_hole_missing_coords = hole_missing_coords[hole_missing_coords[:, 1] &gt; hole_missing_coords[:, 0]]\n\n            possible_swaps = hole_edge_matches(upper_tri_edge_missing_coords, upper_tri_hole_missing_coords)\n\n            for idxs_to_swap in possible_swaps:\n                perm_after_ps = compose_perm_swap(curr_prem, idxs_to_swap)\n                if perm_after_ps not in seen_perms:\n                    seen_perms.add(perm_after_ps)\n                    nodes.append((perm_after_ps, num_of_swaps + 1))\n\n        return False\n\n    def gen_next_graph(current_graph: BitVector, seen_graphs: set[BitString]) -&gt; iter[BitVector]:\n        num_of_nodes = isqrt(len(current_graph))\n        zero_locs = np.where(current_graph == 0)[0]\n        row_idx = zero_locs // num_of_nodes\n        col_idx = zero_locs % num_of_nodes\n        upper_tri_zero_coords = np.column_stack([row_idx[np.where(col_idx &gt; row_idx)[0]], \n                                                col_idx[np.where(col_idx &gt; row_idx)[0]],])\n\n        zero_pairings = combinations(upper_tri_zero_coords, 2)\n\n        def map_coord(coord: tuple[int, int]) -&gt; int:\n            return coord[0] * num_of_nodes + coord[1]\n\n        def invert_coord(coord: tuple[int, int]) -&gt; tuple[int, int]:\n            return coord[1], coord[0]\n\n        def construct_edge_switched_graph(hole_coord_1, hole_coord_2, edge_coord_1, edge_coord_2) -&gt; BitVector:\n            # Picking a rectangle in the matrix with zeros on its diagonal and ones on its other diagonal (4 points)\n            # Reflecting it across the diagonal (4 points)\n            # Setting those 8 points in total\n\n            coords_flipping_to_1 = [hole_coord_1, hole_coord_2, \n                                    invert_coord(hole_coord_1), invert_coord(hole_coord_2)]\n            coords_flipping_to_0 = [edge_coord_1, edge_coord_2, \n                                    invert_coord(edge_coord_1), invert_coord(edge_coord_2)]\n\n            new_graph = current_graph.copy()\n            new_graph[[map_coord(c) for c in coords_flipping_to_1]] = True\n            new_graph[[map_coord(c) for c in coords_flipping_to_0]] = False\n            return new_graph\n\n        for zero_coord_1, zero_coord_2 in zero_pairings:\n            a, b = zero_coord_1\n            c, d = zero_coord_2\n\n            # First possible mapping\n            has_edge_1 = current_graph[map_coord((a, c))]\n            has_edge_2 = current_graph[map_coord((b, d))]\n\n            if not (has_edge_1 and has_edge_2):\n                continue\n\n            p1 = construct_edge_switched_graph(zero_coord_1, zero_coord_2, (a, c), (b, d))\n\n            if (p1_bin_str := to_bin_str(p1)) not in seen_graphs:\n                seen_graphs.add(p1_bin_str)\n                yield p1\n\n            # Second possible mapping\n            has_edge_1 = current_graph[map_coord((a, d))]\n            has_edge_2 = current_graph[map_coord((b, c))]\n\n            if not (has_edge_1 and has_edge_2):\n                continue\n\n            p2 = construct_edge_switched_graph(zero_coord_1, zero_coord_2, (a, d), (b, c))\n\n            if (p2_bin_str := to_bin_str(p2)) not in seen_graphs:\n                seen_graphs.add(p2_bin_str)\n                yield p2\n\n\n    lookup = graph.get_adjacency_matrix()\n    lookup_bin_str = to_bin_str(lookup.flatten())\n    lookup_bin_vec = to_bit_vector(lookup.flatten())\n\n    non_isomorophic_graphs = [lookup_bin_vec]\n    seen_graphs = {lookup_bin_str}\n    nodes = deque([lookup_bin_vec])\n\n    while nodes:\n        current_graph = nodes.popleft()\n        for edge_switched_graph in gen_next_graph(current_graph, seen_graphs):                    \n            is_iso_graph = any((is_isomorphic(non_iso_graph, edge_switched_graph) \n                                for non_iso_graph in non_isomorophic_graphs[::-1]))\n\n            if not is_iso_graph:\n                nodes.append(edge_switched_graph)\n                non_isomorophic_graphs.append(edge_switched_graph)\n\n    return {to_bin_str(g) for g in non_isomorophic_graphs}\n</code></pre>","tags":["Graph","Advanced"]},{"location":"problems/p61_unfold/","title":"Unfold","text":"<p>Implement unfold which applies a function \\(F\\) to a starting value \\(S\\) until a predicate \\(P\\) is true. </p> TestRecursiveIterative <pre><code>def test_unfold(solution):\n    assert list(solution(\n        seed = 5,\n        func = lambda x: x - 1,\n        stop_condition = lambda x: x == 0\n    )) == [5, 4, 3, 2, 1]\n</code></pre> <pre><code>from typing import Callable, Generator\n\ndef unfold_v1[T](seed: T, func: Callable[[T], T], stop_condition: Callable[[T], bool]) -&gt; Generator[T]:\n    if stop_condition(seed):\n        return\n\n    yield seed\n    yield from unfold_v1(func(seed), func, stop_condition)\n</code></pre> <pre><code>from typing import Callable, Generator\n\ndef unfold_v2[T](seed: T, func: Callable[[T], T], stop_condition: Callable[[T], bool]) -&gt; Generator[T]:\n    current_state = seed\n    while not stop_condition(current_state):\n        yield current_state\n        current_state = func(current_state)\n</code></pre>","tags":["Patterns","Intermediate"]},{"location":"problems/p62_fold/","title":"Fold","text":"<p>Implement fold which takes a state \\(S\\), a function \\(F\\), and elements \\(E\\).</p> <p>It applies \\(F(S, E_h)\\) \u2192 \\(S_n\\) where \\(E_h\\) is the head of \\(E\\) and \\(S_n\\) is the new state. Then we move \"forward\" along \\(E\\) and apply again. </p> <p>Repeat this until we run out elements and return the final state.</p> TestRecursiveIterativeDirect <pre><code>def test_fold(solution):\n    assert solution(\n        state = 0,\n        func = lambda acc, next_elem: acc + next_elem,\n        elements = iter([1, 2, 3, 4, 5])\n    ) == 15\n</code></pre> <pre><code>from typing import Callable, Generator\n\ndef fold_v1[T](state: T, func: Callable[[T, T], T], elements: Generator[T]) -&gt; T:\n    if (head := next(elements, None)) is not None:\n        next_state = func(state, head)\n        return fold_v1(next_state, func, elements)\n\n    return state\n</code></pre> <pre><code>from typing import Callable, Generator\n\ndef fold_v2[T](state: T, func: Callable[[T, T], T], elements: Generator[T]) -&gt; T:\n    current_state = state\n    while (head := next(elements, None)) is not None:\n        current_state = func(current_state, head)\n\n    return current_state\n</code></pre> <pre><code>from typing import Callable, Generator\nfrom functools import reduce\n\ndef fold_v3[T](state: T, func: Callable[[T, T], T], elements: Generator[T]) -&gt; T:\n    return reduce(func, elements, state)\n</code></pre>","tags":["Pattern","Intermediate"]},{"location":"problems/p63_linear_recursion/","title":"Linear Recursion","text":"<p>Implement linear recursion which has 4 parts.</p> <p>A function at_base_case which tells us if we reached the base case.</p> <p>A function calulate_base_case which calculates the value when we reach the base case.</p> <p>A function transform which we apply to state before the recursive call.</p> <p>A function combine which combines the state with the result of the recursive call.</p> TestRecursiveIterativeUnfold then Fold <pre><code>def test_linear_recursion(solution):\n    assert solution(\n        state = 5,\n        at_base_case = lambda state: state == 0,\n        calculate_base_case = lambda state: 1,\n        transform = lambda state: state - 1, \n        combine = lambda rec_result, state: state * rec_result\n    ) == 120\n\n\n    assert solution(\n        state = [1, 1, 2, 2, 3, 4, 5, 5],\n        at_base_case = lambda state: len(state) &lt; 1,\n        calculate_base_case = lambda state: state,\n        transform = lambda state: state[1:], \n        combine = lambda rec_result, state: rec_result \n                                            if len(rec_result) &gt; 0 and state[0] == rec_result[0]\n                                            else [state[0]] + rec_result \n    ) == [1, 2, 3, 4, 5]\n</code></pre> <pre><code>from typing import Callable\n\ntype State[T] = T\ntype Result[V] = V\n\ndef linear_recursion_v1(state: State,\n                        at_base_case: Callable[[State], bool],\n                        calculate_base_case: Callable[[State], Result],\n                        transform: Callable[[State], State],\n                        combine: Callable[[Result, State], Result]) -&gt; Result:\n\n    if at_base_case(state):\n        return calculate_base_case(state)\n\n    recursive_result = linear_recursion_v1(transform(state), \n                                           at_base_case, \n                                           calculate_base_case, \n                                           transform, \n                                           combine)\n\n    return combine(recursive_result, state)\n</code></pre> <pre><code>from typing import Callable\n\ntype State[T] = T\ntype Result[V] = V\n\ndef linear_recursion_v2(state: State,\n                        at_base_case: Callable[[State], bool],\n                        calculate_base_case: Callable[[State], Result],\n                        transform: Callable[[State], State],\n                        combine: Callable[[Result, State], Result]) -&gt; Result:\n\n    stack = [state]\n\n    while not at_base_case((current_state := transform(stack[-1]))):\n        stack.append(current_state)\n\n    result = calculate_base_case(current_state)\n\n    while stack:\n        last_state = stack.pop()\n        result = combine(result, last_state)\n\n    return result\n</code></pre> <pre><code>from typing import Callable\nfrom solutions.p61_unfold import unfold_v2\nfrom solutions.p62_fold import fold_v3\n\ntype State[T] = T\ntype Result[V] = V\n\ndef linear_recursion_v3(state: State,\n                        at_base_case: Callable[[State], bool],\n                        calculate_base_case: Callable[[State], Result],\n                        transform: Callable[[State], State],\n                        combine: Callable[[Result, State], Result]) -&gt; Result:\n\n    states = list(unfold_v2(state, transform, at_base_case))\n    base_value = calculate_base_case(states[-1])\n    return fold_v3(base_value, combine, reversed(states))\n</code></pre>","tags":["Pattern","Intermediate"]},{"location":"problems/p64_binary_recursion/","title":"Binary Recursion","text":"<p>Implement binary recursion which has 4 parts.</p> <p>A function at_base_case which tells us if we reached the base case.</p> <p>A function calulate_base_case which calculates the value when we reach the base case.</p> <p>A function transform which outputs 2 values given a state.</p> <p>A function combine which combines the results of the recursive calls with the state.</p> TestRecursive <pre><code>def test_binary_recursion(solution):\n    # Fibonacci\n    assert solution(\n        6,\n        lambda state: state &lt;= 1,\n        lambda state: 1 if state == 1 else 0,\n        lambda state: (state - 1, state - 2),\n        lambda res1, res2, _: res1 + res2\n    ) == 8\n\n    # Merge Sort\n    assert solution(\n        ['z', 'c', 'd', 'b', 'a'],\n        lambda state: len(state) &lt;= 1,\n        lambda state: state,\n        lambda state: (state[:len(state) // 2], state[len(state) // 2:]),\n        lambda res1, res2, _: list(merge(res1, res2))\n    ) == ['a', 'b', 'c', 'd', 'z']\n\n    # Combinations\n    def transform(state):\n        choices, num_remaining = state\n        head, *tail = choices\n        return (tail, num_remaining - 1), (tail, num_remaining)\n\n    def combine(res1, res2, state):\n        head, *_ = state[0]\n        combos_with_head = [(head,) + combo for combo in res1]\n        combos_without_head = res2\n        return combos_with_head + combos_without_head\n\n    assert solution(\n        ([1, 2, 3, 4, 5], 3),\n        lambda state: state[1] == 0 or len(state[0]) &lt; state[1],\n        lambda state: [()] if state[1] == 0 else [],\n        transform,\n        combine\n    ) == list(combinations([1, 2, 3, 4, 5], 3))\n</code></pre> <pre><code>from __future__ import annotations\nfrom typing import Callable\n\ntype State[T] = T\ntype Result[V] = V\n\ndef binary_recursion_v1(state: State,\n                        at_base_case: Callable[[State], bool],\n                        calculate_base_case: Callable[[State], Result],\n                        transform: Callable[[State], tuple[State, State]],\n                        combine: Callable[[Result, Result, State], Result]) -&gt; Result:\n\n    if at_base_case(state):\n        return calculate_base_case(state)\n\n    next_state_1, next_state_2 = transform(state)\n\n    result_from_1 = binary_recursion_v1(next_state_1,\n                                        at_base_case, calculate_base_case,\n                                        transform, combine)\n\n    result_from_2 = binary_recursion_v1(next_state_2,\n                                        at_base_case, calculate_base_case,\n                                        transform, combine)\n\n    return combine(result_from_1, result_from_2, state)\n</code></pre>","tags":["Pattern","Intermediate"]},{"location":"problems/p65_nary_recursion/","title":"Nary Recursion","text":"<p>Implement n-ary recursion which has 4 parts.</p> <p>A function at_base_case which tells us if we reached the base case.</p> <p>A function calulate_base_case which calculates the value when we reach the base case.</p> <p>A function transform which outputs up to N values given a state.</p> <p>A function combine which combines the results of the recursive calls.</p> TestRecursiveIterative <pre><code>def test_nary_recursion(solution):\n    # Merge sort\n    assert solution(\n        ['z', 'c', 'd', 'b', 'a'],\n        lambda state: len(state) &lt;= 1,\n        lambda state: state,\n        lambda state: (state[:len(state) // 2], state[len(state) // 2:]),\n        lambda state, res1, res2: list(merge(res1, res2))\n    ) == ['a', 'b', 'c', 'd', 'z']\n\n    # Square all elements of arb. nested list\n    assert solution(\n        [1, [2, 3], 4, [5, [6]]],\n        lambda state: not isinstance(state, list),\n        lambda state: state * state,\n        lambda state: state,\n        lambda state, *results: list(results)\n    ) == [1, [4, 9], 16, [25, [36]]]\n\n    # Flatten list\n    assert solution(\n        [1, [2, 3], 4, [5, [6]]],\n        lambda state: not isinstance(state, list),\n        lambda state: [state],\n        lambda state: state,\n        lambda state, *results: list(chain.from_iterable(results))\n    ) == [1, 2, 3, 4, 5, 6]\n\n    # Eliminate consecutive duplicates\n    assert solution(\n        [1, 1, 2, 2, 3, 4, 5, 5],\n        lambda state: len(state) &lt;= 2,\n        lambda state: [state[0]] if len(state) == 2 and state[0] == state[1] else state,\n        lambda state: (state[:len(state) // 2], state[len(state) // 2:]),\n        lambda state, res1, res2: res1 + res2[1:] if res1[-1] == res2[0] else res1 + res2 \n    ) == [1, 2, 3, 4, 5]\n\n    # Combinations\n    def transform(state):\n        choices, num_remaining = state\n        head, *tail = choices\n        return (tail, num_remaining - 1), (tail, num_remaining)\n\n    def combine(state, res1, res2):\n        head, *_ = state[0]\n        combos_with_head = [(head,) + combo for combo in res1]\n        combos_without_head = res2\n        return combos_with_head + combos_without_head\n\n    assert solution(\n        ([1, 2, 3, 4, 5], 3),\n        lambda state: state[1] == 0 or len(state[0]) &lt; state[1],\n        lambda state: [()] if state[1] == 0 else [],\n        transform,\n        combine\n    ) == list(combinations([1, 2, 3, 4, 5], 3))\n</code></pre> <pre><code>from __future__ import annotations\nfrom typing import Callable\n\ntype State[T] = T\ntype Result[V] = V\n\ndef nary_recursion_v1(state: State,\n                      at_base_case: Callable[[State], bool],\n                      calculate_base_case: Callable[[State], Result],\n                      transform: Callable[[State], tuple[State, ...]],\n                      combine: Callable[[State, *tuple[Result, ...]], Result]) -&gt; Result:\n\n    if at_base_case(state):\n        return calculate_base_case(state)\n\n    next_states = transform(state)\n    results = (nary_recursion_v1(next_state, at_base_case, calculate_base_case, transform, combine)\n               for next_state in next_states)\n\n    return combine(state, *results)\n</code></pre> <pre><code>from __future__ import annotations\nfrom typing import Callable\nfrom dataclasses import dataclass\n\ntype State[T] = T\ntype Result[V] = V\n\n@dataclass\nclass Unevaluated[State]:\n    value: State\n\n@dataclass\nclass Evaluated[Result]:\n    value: Result\n\ntype Parameter = Unevaluated | Evaluated\n\n@dataclass\nclass FunctionFrame:\n    parnet_state: State\n    parameters: list[Parameter]\n    uneval_idx: int | None\n\n    def __init__(self, parnet_state: State, params: list[Parameter]) -&gt; FunctionFrame:\n        self.parnet_state = parnet_state\n        self.parameters = params\n        self.uneval_idx = next((idx for idx, p in enumerate(params) if isinstance(p, Unevaluated)), None)\n\n    def move_idx(self):\n        if (self.uneval_idx + 1) &gt;= len(self.parameters):\n            self.uneval_idx = None\n        else:\n            self.uneval_idx += 1\n\n\ndef nary_recursion_v2(state: State,\n                      at_base_case: Callable[[State], bool],\n                      calculate_base_case: Callable[[State], Result],\n                      transform: Callable[[State], tuple[State, ...]],\n                      combine: Callable[[State, *tuple[Result, ...]], Result]) -&gt; Result:\n\n    def construct_function_args(s: State) -&gt; list[Parameter]:\n        params = []\n        for next_s in transform(s):\n            if at_base_case(next_s): \n                params.append(Evaluated(calculate_base_case(next_s)))\n            else: \n                params.append(Unevaluated(next_s))\n\n        return params\n\n    if at_base_case(state):\n        return calculate_base_case(state)\n\n    call_stack: list[FunctionFrame] = [FunctionFrame(state, construct_function_args(state))]\n    last_result: Result | None = None\n\n    while call_stack:\n        func: FunctionFrame = call_stack[-1]\n        uneval_idx = func.uneval_idx\n        param = None if uneval_idx is None else func.parameters[uneval_idx]\n\n        match (param, last_result):\n            case (None, None):\n                last_result = combine(func.parnet_state, *(evaluated.value for evaluated in func.parameters))\n                call_stack.pop()\n\n            case (Unevaluated(val), None):\n                new_frame = FunctionFrame(val, construct_function_args(val))\n                call_stack.append(new_frame)\n\n            case (Unevaluated(val), res):\n                func.parameters[uneval_idx] = Evaluated(res)\n                func.move_idx()\n                last_result = None\n\n            case (Evaluated(val), _):\n                func.move_idx()\n\n    return last_result\n</code></pre>","tags":["Pattern","Advanced"]}]}